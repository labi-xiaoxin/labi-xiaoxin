# Java面试知识库

## Java基础

### Java是个面向对象的语言，如何理解面向对象呢？

- 面向对象的三大基本特征：`继承、封装、多态`
  - `继承`：子类继承父类，父类的属性和方法继承到子类。
  - `封装`：将现实世界的事物抽象为一个Java类，该类封装了事物的属性、方法。
  - `多态`：子类继承父类，可以通过`重写(overwrite)`父类方法，实现一个方法具有不同的实现。
- 面向对象的五大基本原则：`单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则`
  - `单一职责原则`：一个类只负责一件事。提高代码可维护性。
  - `开放封闭原则`：对扩展开放，对修改封闭。提高代码可扩展性。
  - `里氏替换原则`：子类必须能够替换其基类。提高代码灵活性。
  - `依赖倒置原则`：方法依赖于抽象接口，而不是具体的实现。降低系统的耦合。
  - `接口隔离原则`：将一个复杂臃肿的接口拆分为更小、更专注的接口。提高代码的灵活性和稳定性。

### Java的继承

- Java只允许多实现，不允许多继承
- 多继承在C++中存在`菱形继承`的问题，Java为了避免该类问题，不允许多继承。
- Java允许多实现，为了避免`菱形继承`的问题，实现的接口如果方法存在重复，就必须`重写(overwrite)`重复的方法。
- Java的接口和抽象类的区别
  - Java8中接口有default方法，其余只能为抽象方法，没有实现代码。而抽象类可以有实现代码。
  - 接口不可以有构造器，抽象类可以有。
  - 接口被实现，抽象类被继承。
  - 接口只能使用`public`修饰符。

### Java的基本类型与包装类型

- 基本类型：`byte、short、int、long、char、float、double、boolean`
- 包装类型：`Byte、Short、Integer、Long、Character、Float、Double、Boolean`
- 包装类型存在的意义：Java是面向对象的语言，很多地方需要使用包装类型而不是基本类型。
- 基本类型默认值为：`0、false、\u0000`,包装类型默认值为：`null`
- Java为了便于开放人员，提供了`自动装箱`、`自动拆箱`的功能
  - `自动装箱`：自动将基本类型转换对应包装类型。通过包装类型的`valueOf()`方法
  - `自动拆箱`：自动将包装类型转换对应基本类型。通过包装类型的`xxxValue()`方法

### Java用什么适合存储金额的类型

Java中，`float`和`double`都是浮点数，浮点数在计算机中都是近似值，因此使用这两个类型存储金额的话，容易产生`计算错误`的问题。
因此，Java中提供了`BigDecimal`进行精确运算。

- `BigDecimal`中的等值比较应使用`compareTo`，而不是`equals`方法。因为`equals`比较`value(值)和scale(标度)`，0.1与0.10的value是一样的，而scale的值是不一样的。
- `BigDecimal`需要准确的运算，那么`BigDecimal(double)`和`BigDecimal(String)`对比，`BigDecimal(String)`的值是准确的，而`BigDecimal(double)`由于double是近似值，因此值是不准确的。

### String、StringBuilder、StringBuffer

- 可变性：String不可变、StringBuilder/StringBffer是可变的。
- 线程安全：StringBuffer、String是线程安全，StringBuilder非线程安全。

### Java的动态代理

- 动态代理：在运行时动态地创建代理对象，并处理代理方法调用的机制。
- 动态代理用途：各种框架中，在运行期生成代理类，如过滤器、拦截器等。
- Java中的动态代理：Spring AOP的动态代理有两种方式：`JDK动态代理`和`Cglib动态代理`
  - `JDK动态代理`：通过反射接收被代理的类。（要求必须要实现一个接口）
  - `Cglib动态代理`：第三方类库，通过继承的方式做动态代理。

### 什么是AIO、BIO、NIO

- `AIO`：`Asynchronous I/O`异步非阻塞I/O模型，操作后会回调通知调用方。
- `BIO`:`Blocking I/O`同步阻塞I/O模型，一直阻塞，直到处理完成。
- `NIO`:`Non-Blocking I/O`同步非阻塞I/O模型，不阻塞，进行其他操作，定时轮询检查。

## Java集合

### Java中的集合类

- 单一元素的集合：`Set、List、Queue、Stack`
- 键值对的集合：`Map`

`Set、List、Queue`都是`Collection`子接口。

### Java集合中的Set

Set在Java体系中，根据实现方式的不同，分为：`HashSet`和`TreeSet`。

#### HashSet

HashSet的实现是通过哈希表，底层基于`HashMap`来存储数据。

- 当添加元素时，首先通过算法计算元素的存储位置，如果位置为空则添加；否则用`equals`判断元素是否相等，相等不添加，不相等则再找个位置进行添加。

HashSet是`线程不安全`，`无序`，`不可重复`。

#### TreeSet

TreeSet的实现是通过红黑树，底层基于`TreeMap`的`keySet()`。

TreeSet是`线程不安全`，`有序`，`不可重复`。

### Java集合中的List

List在Java体系中，根据实现方式的不同，分为：`ArrayList`、`LinkedList`和`Vector`.

#### ArrayList

实现`List`接口，底层是基于`数组`实现，因此具有：`查询快`、`高效随机访问`、`空间占用小`的优点。

##### ArrayList扩容机制

ArrayList是基于`数组`实现，`数组`为定长的，那么ArrayList的自动扩容机制：
1、 检查新元素的添加是否会超过数组的长度，如果超过则进行2
2、 设置`新数组`新的容量为原来的`1.5`倍，将`原数组`复制到`新数组`
3、 扩容完成

#### LinkedList

实现`List`接口，底层是基于`双向链表`实现，因此具有：`插入删除快`的优点，缺点：`低效率随机访问`、`每个节点前后占用空间，空间占用大`

#### Vector

实现`List`接口，类似于`ArrayList`，底层也是基于`数组`实现，不同的是`Vector`增加了线程安全（`synchronized`）的实现，效率相对来说`较低`。

**多线程环境下，Vector并不能够保证复合操作的线程安全。**

### Java集合中的Map

Map在Java体系中，常见的实现类有：`HashMap`、`ConcurrentHashMap`、`LinkedHashMap`、`TreeMap`、`HashTable`。

#### HashMap

**HashMap非线程安全！！！**

默认初始容量：16，默认加载因子：0.75。

##### HashMap数据结构

HashMap的数据结构在不同JDK版本下，有不同的数据结构。

- JDK1.7版本：`数组、链表`
- JDK1.8版本：`数组、链表、红黑树`

数组的特性：`查找快、插入删除慢`
链表的特性：`查找慢、插入删除快`

因此HashMap将`数组`和`链表`组合，充分发挥它们的优点，`数组`的每个成员是个`链表`。这样就能够解决hash冲突时产生的问题，这也叫：`链地址法`。

后来1.8之所以加上`红黑树`的数据结构，是因为在某些极端情况下，`数组`的某个成员的`链表`的长度过程，影响`插入、删除`的效率，在`链表`长度大于8时，会进行`树化`操作，将`链表`转换为`红黑树`。

##### HashMap的get/put方法

- get
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则返回Null；否则进入3
  - 3、遍历对应位置的链表（或红黑树），当键匹配上时，返回该键值对。

- put
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则存储该键值对；否则进入3
  - 3、对应的位置如果元素不为空，则遍历查找是否有键相等的元素；如果有相等元素，则更新旧值为新值，`返回旧值`；否则进入4
  - 4、对应的位置元素不为空，且没有相等元素，将键值对插入对应`链表`或`红黑树`（如果链表满了，则自动转换为红黑树）
  - 5、插入成功返回被替换的值；插入失败返回null
  - 6、判断当前集合是否需要扩容，需要则扩容，否则结束

#### ConcurrentHashMap

**ConcurrentHashMap是线程安全类，相较于HashTable同为线程安全类，性能较高！！！**

ConcurrentHashMap不允许null值，在多线程环境下，如果允许null值存在，那么将带来许多的`不确定性`。

默认初始容量：16，默认加载因子：0.75。

ConcurrentHashMap为保证`线程安全`，在不同JDK版本下，有不同的实现。

- JDK1.7版本：使用`分段锁`保证线程安全，ConcurrentHashMap默认情况下将hash表分为16个桶，在加锁时，仅对某个单独桶进行加锁，其他桶不受影响，因此粒度相较于使用HashTable更小，性能也更好。
- JDK1.8版本：随着`synchronized`的升级，JDK1.8对ConcurrentHashMap实现线程安全的方式也进行了修改：使用`CAS`和`synchronized`。减少内存的开销。
