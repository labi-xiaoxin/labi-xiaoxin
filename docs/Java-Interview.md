# Java面试知识库

## 一、Java基础

### Java是个面向对象的语言，如何理解面向对象呢？

- 面向对象的三大基本特征：`继承、封装、多态`
  - `继承`：子类继承父类，父类的属性和方法继承到子类。
  - `封装`：将现实世界的事物抽象为一个Java类，该类封装了事物的属性、方法。
  - `多态`：子类继承父类，可以通过`重写(overwrite)`父类方法，实现一个方法具有不同的实现。
- 面向对象的五大基本原则：`单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则`
  - `单一职责原则`：一个类只负责一件事。提高代码可维护性。
  - `开放封闭原则`：对扩展开放，对修改封闭。提高代码可扩展性。
  - `里氏替换原则`：子类必须能够替换其基类。提高代码灵活性。
  - `依赖倒置原则`：方法依赖于抽象接口，而不是具体的实现。降低系统的耦合。
  - `接口隔离原则`：将一个复杂臃肿的接口拆分为更小、更专注的接口。提高代码的灵活性和稳定性。

### Java的继承

- Java只允许多实现，不允许多继承
- 多继承在C++中存在`菱形继承`的问题，Java为了避免该类问题，不允许多继承。
- Java允许多实现，为了避免`菱形继承`的问题，实现的接口如果方法存在重复，就必须`重写(overwrite)`重复的方法。
- Java的接口和抽象类的区别
  - Java8中接口有default方法，其余只能为抽象方法，没有实现代码。而抽象类可以有实现代码。
  - 接口不可以有构造器，抽象类可以有。
  - 接口被实现，抽象类被继承。
  - 接口只能使用`public`修饰符。

### Java的基本类型与包装类型

- 基本类型：`byte、short、int、long、char、float、double、boolean`
- 包装类型：`Byte、Short、Integer、Long、Character、Float、Double、Boolean`
- 包装类型存在的意义：Java是面向对象的语言，很多地方需要使用包装类型而不是基本类型。
- 基本类型默认值为：`0、false、\u0000`,包装类型默认值为：`null`
- Java为了便于开放人员，提供了`自动装箱`、`自动拆箱`的功能
  - `自动装箱`：自动将基本类型转换对应包装类型。通过包装类型的`valueOf()`方法
  - `自动拆箱`：自动将包装类型转换对应基本类型。通过包装类型的`xxxValue()`方法

### Java用什么适合存储金额的类型

Java中，`float`和`double`都是浮点数，浮点数在计算机中都是近似值，因此使用这两个类型存储金额的话，容易产生`计算错误`的问题。
因此，Java中提供了`BigDecimal`进行精确运算。

- `BigDecimal`中的等值比较应使用`compareTo`，而不是`equals`方法。因为`equals`比较`value(值)和scale(标度)`，0.1与0.10的value是一样的，而scale的值是不一样的。
- `BigDecimal`需要准确的运算，那么`BigDecimal(double)`和`BigDecimal(String)`对比，`BigDecimal(String)`的值是准确的，而`BigDecimal(double)`由于double是近似值，因此值是不准确的。

### String、StringBuilder、StringBuffer

- 可变性：String不可变、StringBuilder/StringBffer是可变的。
- 线程安全：StringBuffer、String是线程安全，StringBuilder非线程安全。

### Java的动态代理

- 动态代理：在运行时动态地创建代理对象，并处理代理方法调用的机制。
- 动态代理用途：各种框架中，在运行期生成代理类，如过滤器、拦截器等。
- Java中的动态代理：Spring AOP的动态代理有两种方式：`JDK动态代理`和`Cglib动态代理`
  - `JDK动态代理`：通过反射接收被代理的类。（要求必须要实现一个接口）
  - `Cglib动态代理`：第三方类库，通过继承的方式做动态代理。

### 什么是AIO、BIO、NIO

- `AIO`：`Asynchronous I/O`异步非阻塞I/O模型，操作后会回调通知调用方。
- `BIO`:`Blocking I/O`同步阻塞I/O模型，一直阻塞，直到处理完成。
- `NIO`:`Non-Blocking I/O`同步非阻塞I/O模型，不阻塞，进行其他操作，定时轮询检查。

## 二、Java集合

### Java中的集合类

- 单一元素的集合：`Set、List、Queue、Stack`
- 键值对的集合：`Map`

`Set、List、Queue`都是`Collection`子接口。

### Java集合中的Set

Set在Java体系中，根据实现方式的不同，分为：`HashSet`和`TreeSet`。

#### HashSet

HashSet的实现是通过哈希表，底层基于`HashMap`来存储数据。

- 当添加元素时，首先通过算法计算元素的存储位置，如果位置为空则添加；否则用`equals`判断元素是否相等，相等不添加，不相等则再找个位置进行添加。

HashSet是`线程不安全`，`无序`，`不可重复`。

#### TreeSet

TreeSet的实现是通过红黑树，底层基于`TreeMap`的`keySet()`。

TreeSet是`线程不安全`，`有序`，`不可重复`。

### Java集合中的List

List在Java体系中，根据实现方式的不同，分为：`ArrayList`、`LinkedList`和`Vector`.

#### ArrayList

实现`List`接口，底层是基于`数组`实现，因此具有：`查询快`、`高效随机访问`、`空间占用小`的优点。

##### ArrayList扩容机制

ArrayList是基于`数组`实现，`数组`为定长的，那么ArrayList的自动扩容机制：
1、 检查新元素的添加是否会超过数组的长度，如果超过则进行2
2、 设置`新数组`新的容量为原来的`1.5`倍，将`原数组`复制到`新数组`
3、 扩容完成

#### LinkedList

实现`List`接口，底层是基于`双向链表`实现，因此具有：`插入删除快`的优点，缺点：`低效率随机访问`、`每个节点前后占用空间，空间占用大`

#### Vector

实现`List`接口，类似于`ArrayList`，底层也是基于`数组`实现，不同的是`Vector`增加了线程安全（`synchronized`）的实现，效率相对来说`较低`。

**多线程环境下，Vector并不能够保证复合操作的线程安全。**

### Java集合中的Map

Map在Java体系中，常见的实现类有：`HashMap`、`ConcurrentHashMap`、`LinkedHashMap`、`TreeMap`、`HashTable`。

#### HashMap

**HashMap非线程安全！！！**

默认初始容量：16，默认加载因子：0.75。

##### HashMap数据结构

HashMap的数据结构在不同JDK版本下，有不同的数据结构。

- JDK1.7版本：`数组、链表`
- JDK1.8版本：`数组、链表、红黑树`

数组的特性：`查找快、插入删除慢`
链表的特性：`查找慢、插入删除快`

因此HashMap将`数组`和`链表`组合，充分发挥它们的优点，`数组`的每个成员是个`链表`。这样就能够解决hash冲突时产生的问题，这也叫：`链地址法`。

后来1.8之所以加上`红黑树`的数据结构，是因为在某些极端情况下，`数组`的某个成员的`链表`的长度过程，影响`插入、删除`的效率，在`链表`长度大于8时，会进行`树化`操作，将`链表`转换为`红黑树`。

##### HashMap的get/put方法

- get
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则返回Null；否则进入3
  - 3、遍历对应位置的链表（或红黑树），当键匹配上时，返回该键值对。

- put
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则存储该键值对；否则进入3
  - 3、对应的位置如果元素不为空，则遍历查找是否有键相等的元素；如果有相等元素，则更新旧值为新值，`返回旧值`；否则进入4
  - 4、对应的位置元素不为空，且没有相等元素，将键值对插入对应`链表`或`红黑树`（如果链表满了，则自动转换为红黑树）
  - 5、插入成功返回被替换的值；插入失败返回null
  - 6、判断当前集合是否需要扩容，需要则扩容，否则结束

#### ConcurrentHashMap

**ConcurrentHashMap是线程安全类，相较于HashTable同为线程安全类，性能较高！！！**

ConcurrentHashMap不允许null值，在多线程环境下，如果允许null值存在，那么将带来许多的`不确定性`。

默认初始容量：16，默认加载因子：0.75。

ConcurrentHashMap为保证`线程安全`，在不同JDK版本下，有不同的实现。

- JDK1.7版本：使用`分段锁`保证线程安全，ConcurrentHashMap默认情况下将hash表分为16个桶，在加锁时，仅对某个单独桶进行加锁，其他桶不受影响，因此粒度相较于使用HashTable更小，性能也更好。
- JDK1.8版本：随着`synchronized`的升级，JDK1.8对ConcurrentHashMap实现线程安全的方式也进行了修改：使用`CAS`和`synchronized`。减少内存的开销。

## 三、Java多线程

### 什么是多线程

#### 线程和进程

理解`多线程`前，先理解什么是线程，什么是进程。

- 进程：程序执行的一个实例，如windows下任务管理器中可看到，一个个进程。
- 线程：进程中的一个独立执行单位，一个进程可以包含多个线程。（如实例图中，vs code应用有10个线程）

![windows10任务管理器](https://cdn.jsdelivr.net/gh/labi-xiaoxin/img/202403171557810.png)

#### Java中线程的6个状态

- 1、 NEW：新建了线程，线程处于未执行`.start()`方法的状态。
- 2、 RUNNABLE：运行状态。Java中对于`READY(就绪)`和`RUNNING(运行中)`没有严格的区分，统一为`RUNNABLE`状态。
- 3、 BLOCKED：阻塞。
- 4、 WAITING：等待。
- 5、 TIMED_WAITING：超时等待。
- 6、 TERMINATED：终止。

多线程是指在一个程序中**同时**执行多个线程的能力，也就是一个进程中执行多个线程的能力。每个线程都是程序中的一个单独的执行路径，可以独立运行，但又共享相同的资源，如内存空间、文件句柄等。多线程允许程序同时执行多个任务，从而提高了程序的并发性和性能。

多线程中有个重要的概念：`上下文切换`，它的意思是指：CPU从一个线程切换到另一个线程时，保存原线程的上下文状态，恢复切换线程的上下文状态。

由于需要`保存`和`恢复`的动作，导致`多线程`的`上下文切换`不允许过多，否则容易导致`系统的运行效率降低`。

### 多线程带来的线程安全

线程安全：在多线程环境下，能够正确的处理多个线程之间的`共享变量`，使程序按照预期的结果运行。

#### Java创建线程的方式

- 继承Thread类
- 实现Runnable接口
- Callable和FutureTask创建线程
- 线程池创建线程

#### run/start、wait/sleep、notify/notifyAll区别

- 1、run/start
run是在单线程中运行run方法；start是启动一个线程执行run方法。

- 2、wait/sleep
sleep：不会释放对象锁，线程进入TIMED_WAITING超时等待状态，可以在任何地方使用。
wait：会释放对象锁，线程进入WAITING等待状态，只能用在`同步代码块或同步方法`。

- 3、notify/notifyAll
notify唤醒单个处于WAITING状态的线程；notifyAll唤醒所有。

#### ThreadLocal是什么

用来存放私有线程的数据。

`线程间私有，线程内共享`。

#### synchronized关键字

`synchronized`作为Java中一个重要关键字，用来加锁，支持：`方法加锁`、`代码块加锁`。

`方法加锁`：同步方法的常量池存在`ACC_SYNCHRONIZED`标志。通过该标志，判断是否需要获取`监视器锁`。
`代码块加锁`：同步代码块使用`monitorenter`和`monitorexit`指令实现加锁和释放锁。

#### synchronized锁升级

JDK1.6及之前版本：是通过`监视器锁`实现，这时候的锁是`重量级锁`，因而早期版本JDK不推荐使用`synchronized`关键字加锁。
JDK1.6之后：引入`偏向锁`、`轻量级锁`、`重量级锁`。
锁升级的过程便是：`无锁`——> `偏向锁`——> `轻量级锁`——> `重量级锁`

##### 偏向锁

线程首次进入synchronized块时，自动由`无锁`转为`偏向锁`。当同一时间，其他线程尝试访问对象时，由于对象头中的`线程ID`不同，此时锁会升级为`轻量级锁`。

##### 轻量级锁

其他线程尝试获取轻量级锁时，会有2个步骤：
1、 对象头的Mark Word复制到线程栈中的锁记录（Lock Record）
2、 尝试替换对象头的Mark Word（通过CAS尝试）

当CAS失败时，`轻量级锁`会升级为`重量级锁`

##### 重量级锁

当锁为`重量级锁`时，对象头记录指向等待队列（等待获取重量级锁的队列）的指针。

其他线程尝试获取重量级锁时，需要先进入等待队列，等待该锁被释放。然后被JVM唤醒。

#### volatile

volatile也是Java中的一个关键字，但它仅能对`变量`进行修饰。

它具有：`有序性`和`可见性`的特征。不具有`原子性`。

可见性：volatile修饰的变量每次修改都会刷入主存，因此其他线程都能够看见修改的值。
有序性：通过`内存屏障`，禁止了指令重排，因而保证了代码严格按照顺序执行。

### Java虚拟机（JVM）

#### Java平台无关性

Java有个特性叫：平台无关性。意思是在计算机上运行时，与使用的平台（windows、linux等）无关，不受不同系统的约束。

Java语言通过JVM(Java Virtual Machine)来实现这个特性。不同平台下载不同平台对应的JVM，Java语言通过JVM进行编译，编译为不同平台的二进制文件，这样就能够实现多平台运行。

#### JVM运行时内存区域

JVM运行时内存区域包含：`Java堆`、`运行时常量池`、`方法区`、`Java虚拟机栈`、`本地方法栈`、`程序计数器` 

- Java堆：存储对象实例的区域，线程间共享。是内存总体最大的一块，Java中的垃圾回收也是对于堆进行垃圾回收的。
- 运行时常量池：方法区的一部分，线程间共享。存储编译阶段产生的信息，`符号引用常量`、`字面量`。
- 方法区：线程间共享，存储已被加载的：`类信息`、`常量`、`静态变量`、`即时编译的代码`
- Java虚拟机栈：线程私有，存储局部变量，每次操作方法都会创建一个`栈帧`，方法操作完成，`栈帧`弹出，数据清除。
- 本地方法栈：线程私有，本地方法类似于C语言之类的实现，本地方法栈存储本地方法的`参数`、`局部变量`等信息。
- 程序计数器：线程私有，每个线程独立维护一个程序计数器，用于`指示下一个要被执行的指令的位置`。

#### 什么是分代？什么是新生区？什么是老年区？

Java中分代一般是指：堆内存的分代；将堆内存`不同生命周期的对象`存储在堆内存中`不同的区域`，这就是Java中的堆内存分代。

Java根据不同生命周期，将堆内存区域划分为：`新生区（新生代）`、`老年区（老年代）`。

`新生区`：新分配的对象。其中又分为：`Eden(伊甸园)`、`From(幸存区From)`、`To(幸存区To)`。对象默认先进入Eden区，在Eden满了之后，触发GC，GC会判断对象是否存活，存活则进入`幸存区`。当`幸存区`满了之后，存活的对象进入`老年区`。

`老年区`：长期存在的对象。经过多轮的GC依旧存活的对象，进行回收时较慢。

#### Java中的Stop The World

简称STW，在JVM垃圾回收时，Java只保留垃圾回收线程，其他线程均被挂起。这就是Stop The World。只有其他线程挂起，这样垃圾回收才能正常执行，否则会出现垃圾清理不完全、标记算法出现`漏标`、`多标`等问题。

#### JVM垃圾回收算法盘点

- 标记-清除
最为简单的一种垃圾回收算法，标记对象为垃圾，然后清除该对象。
缺点同样也很突出：清除对象后，留下的内存空间并非连续的，会产生许多`内存碎片`。
- 标记-复制
由于`标记-清除`算法的缺点太过于突出，于是`标记-复制`算法便随之产生。将内存划分为2个区域，标记对象为垃圾，将存活对象复制到另一个内存空间（复制空间上是连续的），然后清除标记的对象。
缺点就是内存需要预留1个区域进行复制。
- 标记-整理
`标记-清除`、`标记-复制`都有明细的缺点，`标记-整理`就是结合了前两者进行设计的。
`标记-整理`分为2步骤：
- 标记：将存活对象标记
- 整理：移动存活对象，按照内存地址次序依次排列，排列完成后回收其余空间。
缺点:标记、整理耗费时间较多，性能不高。

#### JVM判断对象存活

- 可达性分析算法：从一组称为GC Roots的对象开始，通过这些对象向下搜索其他对象，形成引用链。

有两次标记：
  1、 可达性分析算法标记。
  2、 `finalize()`方法是否被覆盖且没有执行过，没有执行过则会进行二次标记，然后回收。 

- 引用计数法：对象被引用时，计数器加1，引用失效时，计数器减1。基本没有使用这个算法，无法解决循环引用问题。

#### 三色标记算法

JVM中垃圾标记的算法，在CMS、G1等垃圾回收算法中主要使用的算法。

将对象分为3种颜色：

- 白色：没有被标记过。
- 灰色：被标记过，引用对象还没标记完。
- 黑色：被标记过，引用对象已标记完。

标记对象步骤分为三步：

- 初始标记：需要STW挂起其他线程进行标记。将根对象以及直接引用的对象标记灰色。
- 并发标记：并发标记，不需要STW挂起其他线程。从灰色对象遍历对象，遍历完成对象标记为黑色。由于是并发状态下，需要使用`写屏障（Write Barrier）`技术来保证准确性。
- 重新标记：需要STW挂起其他线程进行标记，从灰色对象遍历对象，遍历完成对象标记为黑色。

标记完成后，白色为不可达对象，正常情况下会被垃圾回收。

#### JVM常见监控工具

- Jmap：JVM自带的命令行工具，可以生成JVM堆内存的dump文件，分析堆内存使用情况。
- 商业软件：JProfile：监视内存、线程、GC等信息。
- Arthas：阿里巴巴开源的Java诊断工具。

#### JVM常用调参

1、 堆设置：`-Xms（堆初始大小） -Xmx（堆最大大小）`
2、 栈设置：`-Xss（线程的栈大小）`
3、 垃圾回收设置：`-XX:+UseG1GC（使用G1垃圾回收器） -XX:+UseParallelGC（使用并行垃圾回收器）`
4、 元空间设置(1.8)：`-XX:MetaspaceSize（元空间初始大小） -XX:MaxMeatspaceSize（元空间最大大小）`
5、 打印垃圾回收信息：`-XX:PrintGCDetails`
6、 内存溢出时，生成dump文件：`-XX:+HeapDumpOnOutOfMemoryError`
