# Java面试知识库

## 一、Java基础

### 1.1 Java是个面向对象的语言，如何理解面向对象呢？

- 面向对象的三大基本特征：`继承、封装、多态`
  - `继承`：子类继承父类，父类的属性和方法继承到子类。
  - `封装`：将现实世界的事物抽象为一个Java类，该类封装了事物的属性、方法。
  - `多态`：子类继承父类，可以通过`重写(overwrite)`父类方法，实现一个方法具有不同的实现。
- 面向对象的五大基本原则：`单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则`
  - `单一职责原则`：一个类只负责一件事。提高代码可维护性。
  - `开放封闭原则`：对扩展开放，对修改封闭。提高代码可扩展性。
  - `里氏替换原则`：子类必须能够替换其基类。提高代码灵活性。
  - `依赖倒置原则`：方法依赖于抽象接口，而不是具体的实现。降低系统的耦合。
  - `接口隔离原则`：将一个复杂臃肿的接口拆分为更小、更专注的接口。提高代码的灵活性和稳定性。

### 1.2 Java的继承

- Java只允许多实现，不允许多继承
- 多继承在C++中存在`菱形继承`的问题，Java为了避免该类问题，不允许多继承。
- Java允许多实现，为了避免`菱形继承`的问题，实现的接口如果方法存在重复，就必须`重写(overwrite)`重复的方法。
- Java的接口和抽象类的区别
  - Java8中接口有default方法，其余只能为抽象方法，没有实现代码。而抽象类可以有实现代码。
  - 接口不可以有构造器，抽象类可以有。
  - 接口被实现，抽象类被继承。
  - 接口只能使用`public`修饰符。

### 1.3 Java的基本类型与包装类型

- 基本类型：`byte、short、int、long、char、float、double、boolean`
- 包装类型：`Byte、Short、Integer、Long、Character、Float、Double、Boolean`
- 包装类型存在的意义：Java是面向对象的语言，很多地方需要使用包装类型而不是基本类型。
- 基本类型默认值为：`0、false、\u0000`,包装类型默认值为：`null`
- Java为了便于开放人员，提供了`自动装箱`、`自动拆箱`的功能
  - `自动装箱`：自动将基本类型转换对应包装类型。通过包装类型的`valueOf()`方法
  - `自动拆箱`：自动将包装类型转换对应基本类型。通过包装类型的`xxxValue()`方法

### 1.4 Java用什么适合存储金额的类型

Java中，`float`和`double`都是浮点数，浮点数在计算机中都是近似值，因此使用这两个类型存储金额的话，容易产生`计算错误`的问题。
因此，Java中提供了`BigDecimal`进行精确运算。

- `BigDecimal`中的等值比较应使用`compareTo`，而不是`equals`方法。因为`equals`比较`value(值)和scale(标度)`，0.1与0.10的value是一样的，而scale的值是不一样的。
- `BigDecimal`需要准确的运算，那么`BigDecimal(double)`和`BigDecimal(String)`对比，`BigDecimal(String)`的值是准确的，而`BigDecimal(double)`由于double是近似值，因此值是不准确的。

### 1.5 String、StringBuilder、StringBuffer

- 可变性：String不可变、StringBuilder/StringBffer是可变的。
- 线程安全：StringBuffer、String是线程安全，StringBuilder非线程安全。

### 1.6 Java的动态代理

- 动态代理：在运行时动态地创建代理对象，并处理代理方法调用的机制。
- 动态代理用途：各种框架中，在运行期生成代理类，如过滤器、拦截器等。
- Java中的动态代理：Spring AOP的动态代理有两种方式：`JDK动态代理`和`Cglib动态代理`
  - `JDK动态代理`：通过反射接收被代理的类。（要求必须要实现一个接口）
  - `Cglib动态代理`：第三方类库，通过继承的方式做动态代理。

### 1.7 什么是AIO、BIO、NIO

- `AIO`：`Asynchronous I/O`异步非阻塞I/O模型，操作后会回调通知调用方。
- `BIO`:`Blocking I/O`同步阻塞I/O模型，一直阻塞，直到处理完成。
- `NIO`:`Non-Blocking I/O`同步非阻塞I/O模型，不阻塞，进行其他操作，定时轮询检查。

## 二、Java集合

### 2.1 Java中的集合类

- 单一元素的集合：`Set、List、Queue、Stack`
- 键值对的集合：`Map`

`Set、List、Queue`都是`Collection`子接口。

### 2.2 Java集合中的Set

Set在Java体系中，根据实现方式的不同，分为：`HashSet`和`TreeSet`。

#### 2.2.1 HashSet

HashSet的实现是通过哈希表，底层基于`HashMap`来存储数据。

- 当添加元素时，首先通过算法计算元素的存储位置，如果位置为空则添加；否则用`equals`判断元素是否相等，相等不添加，不相等则再找个位置进行添加。

HashSet是`线程不安全`，`无序`，`不可重复`。

#### 2.2.2 TreeSet

TreeSet的实现是通过红黑树，底层基于`TreeMap`的`keySet()`。

TreeSet是`线程不安全`，`有序`，`不可重复`。

### 2.3 Java集合中的List

List在Java体系中，根据实现方式的不同，分为：`ArrayList`、`LinkedList`和`Vector`.

#### 2.3.1 ArrayList

实现`List`接口，底层是基于`数组`实现，因此具有：`查询快`、`高效随机访问`、`空间占用小`的优点。

##### 2.3.1.1 ArrayList扩容机制

ArrayList是基于`数组`实现，`数组`为定长的，那么ArrayList的自动扩容机制：
1、 检查新元素的添加是否会超过数组的长度，如果超过则进行2
2、 设置`新数组`新的容量为原来的`1.5`倍，将`原数组`复制到`新数组`
3、 扩容完成

#### 2.3.2 LinkedList

实现`List`接口，底层是基于`双向链表`实现，因此具有：`插入删除快`的优点，缺点：`低效率随机访问`、`每个节点前后占用空间，空间占用大`

#### Vector

实现`List`接口，类似于`ArrayList`，底层也是基于`数组`实现，不同的是`Vector`增加了线程安全（`synchronized`）的实现，效率相对来说`较低`。

**多线程环境下，Vector并不能够保证复合操作的线程安全。**

### 2.4 Java集合中的Map

Map在Java体系中，常见的实现类有：`HashMap`、`ConcurrentHashMap`、`LinkedHashMap`、`TreeMap`、`HashTable`。

#### 2.4.1 HashMap

**HashMap非线程安全！！！**

默认初始容量：16，默认加载因子：0.75。

##### 2.4.1.1 HashMap数据结构

HashMap的数据结构在不同JDK版本下，有不同的数据结构。

- JDK1.7版本：`数组、链表`
- JDK1.8版本：`数组、链表、红黑树`

数组的特性：`查找快、插入删除慢`
链表的特性：`查找慢、插入删除快`

因此HashMap将`数组`和`链表`组合，充分发挥它们的优点，`数组`的每个成员是个`链表`。这样就能够解决hash冲突时产生的问题，这也叫：`链地址法`。

后来1.8之所以加上`红黑树`的数据结构，是因为在某些极端情况下，`数组`的某个成员的`链表`的长度过程，影响`插入、删除`的效率，在`链表`长度大于8时，会进行`树化`操作，将`链表`转换为`红黑树`。

##### 2.4.1.2 HashMap的get/put方法

- get
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则返回Null；否则进入3
  - 3、遍历对应位置的链表（或红黑树），当键匹配上时，返回该键值对。

- put
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则存储该键值对；否则进入3
  - 3、对应的位置如果元素不为空，则遍历查找是否有键相等的元素；如果有相等元素，则更新旧值为新值，`返回旧值`；否则进入4
  - 4、对应的位置元素不为空，且没有相等元素，将键值对插入对应`链表`或`红黑树`（如果链表满了，则自动转换为红黑树）
  - 5、插入成功返回被替换的值；插入失败返回null
  - 6、判断当前集合是否需要扩容，需要则扩容，否则结束

#### 2.4.2 ConcurrentHashMap

**ConcurrentHashMap是线程安全类，相较于HashTable同为线程安全类，性能较高！！！**

ConcurrentHashMap不允许null值，在多线程环境下，如果允许null值存在，那么将带来许多的`不确定性`。

默认初始容量：16，默认加载因子：0.75。

ConcurrentHashMap为保证`线程安全`，在不同JDK版本下，有不同的实现。

- JDK1.7版本：使用`分段锁`保证线程安全，ConcurrentHashMap默认情况下将hash表分为16个桶，在加锁时，仅对某个单独桶进行加锁，其他桶不受影响，因此粒度相较于使用HashTable更小，性能也更好。
- JDK1.8版本：随着`synchronized`的升级，JDK1.8对ConcurrentHashMap实现线程安全的方式也进行了修改：使用`CAS`和`synchronized`。减少内存的开销。

## 三、Java多线程

### 3.1 什么是多线程

#### 3.1.1 线程和进程

理解`多线程`前，先理解什么是线程，什么是进程。

- 进程：程序执行的一个实例，如windows下任务管理器中可看到，一个个进程。
- 线程：进程中的一个独立执行单位，一个进程可以包含多个线程。（如实例图中，vs code应用有10个线程）

![windows10任务管理器](https://cdn.jsdelivr.net/gh/labi-xiaoxin/img/202403171557810.png)

#### 3.1.2 Java中线程的6个状态

- 1、 NEW：新建了线程，线程处于未执行`.start()`方法的状态。
- 2、 RUNNABLE：运行状态。Java中对于`READY(就绪)`和`RUNNING(运行中)`没有严格的区分，统一为`RUNNABLE`状态。
- 3、 BLOCKED：阻塞。
- 4、 WAITING：等待。
- 5、 TIMED_WAITING：超时等待。
- 6、 TERMINATED：终止。

多线程是指在一个程序中**同时**执行多个线程的能力，也就是一个进程中执行多个线程的能力。每个线程都是程序中的一个单独的执行路径，可以独立运行，但又共享相同的资源，如内存空间、文件句柄等。多线程允许程序同时执行多个任务，从而提高了程序的并发性和性能。

多线程中有个重要的概念：`上下文切换`，它的意思是指：CPU从一个线程切换到另一个线程时，保存原线程的上下文状态，恢复切换线程的上下文状态。

由于需要`保存`和`恢复`的动作，导致`多线程`的`上下文切换`不允许过多，否则容易导致`系统的运行效率降低`。

### 3.2 多线程带来的线程安全

线程安全：在多线程环境下，能够正确的处理多个线程之间的`共享变量`，使程序按照预期的结果运行。

#### 3.2.1 Java创建线程的方式

- 继承Thread类
- 实现Runnable接口
- Callable和FutureTask创建线程
- 线程池创建线程

#### 3.2.2 run/start、wait/sleep、notify/notifyAll区别

- 1、run/start
run是在单线程中运行run方法；start是启动一个线程执行run方法。

- 2、wait/sleep
sleep：不会释放对象锁，线程进入TIMED_WAITING超时等待状态，可以在任何地方使用。
wait：会释放对象锁，线程进入WAITING等待状态，只能用在`同步代码块或同步方法`。

- 3、notify/notifyAll
notify唤醒单个处于WAITING状态的线程；notifyAll唤醒所有。

#### 3.2.3 ThreadLocal是什么

用来存放私有线程的数据。

`线程间私有，线程内共享`。

#### 3.2.4 synchronized关键字

`synchronized`作为Java中一个重要关键字，用来加锁，支持：`方法加锁`、`代码块加锁`。

`方法加锁`：同步方法的常量池存在`ACC_SYNCHRONIZED`标志。通过该标志，判断是否需要获取`监视器锁`。
`代码块加锁`：同步代码块使用`monitorenter`和`monitorexit`指令实现加锁和释放锁。

#### 3.2.5 synchronized锁升级

JDK1.6及之前版本：是通过`监视器锁`实现，这时候的锁是`重量级锁`，因而早期版本JDK不推荐使用`synchronized`关键字加锁。
JDK1.6之后：引入`偏向锁`、`轻量级锁`、`重量级锁`。
锁升级的过程便是：`无锁`——> `偏向锁`——> `轻量级锁`——> `重量级锁`

##### 3.2.5.1 偏向锁

线程首次进入synchronized块时，自动由`无锁`转为`偏向锁`。当同一时间，其他线程尝试访问对象时，由于对象头中的`线程ID`不同，此时锁会升级为`轻量级锁`。

##### 3.2.5.2 轻量级锁

其他线程尝试获取轻量级锁时，会有2个步骤：
1、 对象头的Mark Word复制到线程栈中的锁记录（Lock Record）
2、 尝试替换对象头的Mark Word（通过CAS尝试）

当CAS失败时，`轻量级锁`会升级为`重量级锁`

##### 3.2.5.3 重量级锁

当锁为`重量级锁`时，对象头记录指向等待队列（等待获取重量级锁的队列）的指针。

其他线程尝试获取重量级锁时，需要先进入等待队列，等待该锁被释放。然后被JVM唤醒。

#### 3.2.6 volatile

volatile也是Java中的一个关键字，但它仅能对`变量`进行修饰。

它具有：`有序性`和`可见性`的特征。不具有`原子性`。

可见性：volatile修饰的变量每次修改都会刷入主存，因此其他线程都能够看见修改的值。
有序性：通过`内存屏障`，禁止了指令重排，因而保证了代码严格按照顺序执行。

### 3.3 Java虚拟机（JVM）

#### 3.3.1 Java平台无关性

Java有个特性叫：平台无关性。意思是在计算机上运行时，与使用的平台（windows、linux等）无关，不受不同系统的约束。

Java语言通过JVM(Java Virtual Machine)来实现这个特性。不同平台下载不同平台对应的JVM，Java语言通过JVM进行编译，编译为不同平台的二进制文件，这样就能够实现多平台运行。

#### 3.3.2 JVM运行时内存区域

JVM运行时内存区域包含：`Java堆`、`运行时常量池`、`方法区`、`Java虚拟机栈`、`本地方法栈`、`程序计数器` 

- Java堆：存储对象实例的区域，线程间共享。是内存总体最大的一块，Java中的垃圾回收也是对于堆进行垃圾回收的。
- 运行时常量池：方法区的一部分，线程间共享。存储编译阶段产生的信息，`符号引用常量`、`字面量`。
- 方法区：线程间共享，存储已被加载的：`类信息`、`常量`、`静态变量`、`即时编译的代码`
- Java虚拟机栈：线程私有，存储局部变量，每次操作方法都会创建一个`栈帧`，方法操作完成，`栈帧`弹出，数据清除。
- 本地方法栈：线程私有，本地方法类似于C语言之类的实现，本地方法栈存储本地方法的`参数`、`局部变量`等信息。
- 程序计数器：线程私有，每个线程独立维护一个程序计数器，用于`指示下一个要被执行的指令的位置`。

#### 3.3.3 什么是分代？什么是新生区？什么是老年区？

Java中分代一般是指：堆内存的分代；将堆内存`不同生命周期的对象`存储在堆内存中`不同的区域`，这就是Java中的堆内存分代。

Java根据不同生命周期，将堆内存区域划分为：`新生区（新生代）`、`老年区（老年代）`。

`新生区`：新分配的对象。其中又分为：`Eden(伊甸园)`、`From(幸存区From)`、`To(幸存区To)`。对象默认先进入Eden区，在Eden满了之后，触发GC，GC会判断对象是否存活，存活则进入`幸存区`。当`幸存区`满了之后，存活的对象进入`老年区`。

`老年区`：长期存在的对象。经过多轮的GC依旧存活的对象，进行回收时较慢。

#### 3.3.4 Java中的Stop The World

简称STW，在JVM垃圾回收时，Java只保留垃圾回收线程，其他线程均被挂起。这就是Stop The World。只有其他线程挂起，这样垃圾回收才能正常执行，否则会出现垃圾清理不完全、标记算法出现`漏标`、`多标`等问题。

#### 3.3.5 JVM垃圾回收算法盘点

- 标记-清除
最为简单的一种垃圾回收算法，标记对象为垃圾，然后清除该对象。
缺点同样也很突出：清除对象后，留下的内存空间并非连续的，会产生许多`内存碎片`。
- 标记-复制
由于`标记-清除`算法的缺点太过于突出，于是`标记-复制`算法便随之产生。将内存划分为2个区域，标记对象为垃圾，将存活对象复制到另一个内存空间（复制空间上是连续的），然后清除标记的对象。
缺点就是内存需要预留1个区域进行复制。
- 标记-整理
`标记-清除`、`标记-复制`都有明细的缺点，`标记-整理`就是结合了前两者进行设计的。
`标记-整理`分为2步骤：
- 标记：将存活对象标记
- 整理：移动存活对象，按照内存地址次序依次排列，排列完成后回收其余空间。
缺点:标记、整理耗费时间较多，性能不高。

#### 3.3.6 JVM判断对象存活

- 可达性分析算法：从一组称为GC Roots的对象开始，通过这些对象向下搜索其他对象，形成引用链。

有两次标记：
  1、 可达性分析算法标记。
  2、 `finalize()`方法是否被覆盖且没有执行过，没有执行过则会进行二次标记，然后回收。 

- 引用计数法：对象被引用时，计数器加1，引用失效时，计数器减1。基本没有使用这个算法，无法解决循环引用问题。

#### 3.3.7 三色标记算法

JVM中垃圾标记的算法，在CMS、G1等垃圾回收算法中主要使用的算法。

将对象分为3种颜色：

- 白色：没有被标记过。
- 灰色：被标记过，引用对象还没标记完。
- 黑色：被标记过，引用对象已标记完。

标记对象步骤分为三步：

- 初始标记：需要STW挂起其他线程进行标记。将根对象以及直接引用的对象标记灰色。
- 并发标记：并发标记，不需要STW挂起其他线程。从灰色对象遍历对象，遍历完成对象标记为黑色。由于是并发状态下，需要使用`写屏障（Write Barrier）`技术来保证准确性。
- 重新标记：需要STW挂起其他线程进行标记，从灰色对象遍历对象，遍历完成对象标记为黑色。

标记完成后，白色为不可达对象，正常情况下会被垃圾回收。

#### 3.3.8 JVM常见监控工具

- Jmap：JVM自带的命令行工具，可以生成JVM堆内存的dump文件，分析堆内存使用情况。
- 商业软件：JProfile：监视内存、线程、GC等信息。
- Arthas：阿里巴巴开源的Java诊断工具。

#### 3.3.9 JVM常用调参

1、 堆设置：`-Xms（堆初始大小） -Xmx（堆最大大小）`
2、 栈设置：`-Xss（线程的栈大小）`
3、 垃圾回收设置：`-XX:+UseG1GC（使用G1垃圾回收器） -XX:+UseParallelGC（使用并行垃圾回收器）`
4、 元空间设置(1.8)：`-XX:MetaspaceSize（元空间初始大小） -XX:MaxMeatspaceSize（元空间最大大小）`
5、 打印垃圾回收信息：`-XX:PrintGCDetails`
6、 内存溢出时，生成dump文件：`-XX:+HeapDumpOnOutOfMemoryError`

## 四、Spring全家桶 

### 4.1 Spring之IoC

IoC：inversion of control，控制反转。

具体到代码中的释义如下：

>代码中一个个对象的创建、管理，原先是由用户一个个`new`出来进行使用，而Spring将对象的创建、管理控制权，交由Spring容器进行管理。需要使用对象时，则通过Spring容器中获取对象即可。

这样的特性，能够极大地`降低代码的复杂度`，`无需关注引用对象的细节`，`避免重复创建对象导致空间浪费`。

### 4.2 Spring之AOP

AOP：Aspect-Oriented Programming,面向切面编程。

具体到代码中的释义如下：

>一段代码可能包含：日志打印、业务核心、接口校验、事务管理等等，其中核心便是：`业务核心`，其余功能点均是在这个`业务核心`之外的，那么就能够把其他功能看作是不同`切面`。

这样，业务代码就能够与其它不同功能的代码解耦，具体代码只专注于业务的准确性即可。

SpringAOP的实现方式有2种：`Jdk动态代理`、`Cglib动态代理`

其不同点是：**jdk动态代理只能代理有接口的类；cglib用于代理没有接口的类**。

### 4.3 Spring之Bean生命周期

>创建（实例化、初始化） ——> 使用 ——>销毁

Spring如一个世界，其中的Bean如现实世界中的人。与人类似，有着`出生`->`成长`->`死亡`的三个阶段，人的成长是一个过程，Bean的使用也是一个过程。

- Bean出生：
  - 1、实例化：Spring容器创建Bean实例
  - 2、初始化：`设置属性值->执行Aware接口方法->BeanPostProcessor前置处理->InitializingBean处理->自定义init-method方法->BeanPostProcessor后置处理`
- Bean成长
  - 1、正常使用
- Bean死亡
  - 1、销毁：自定义的destory-method方法销毁Bean

### 4.4 Spring之事务传播机制

Spring有7种事务传播机制，对应以下7种：

- REQUIRED：默认事务传播机制。如果没有事务则开启新事务，如果有事务则加入事务。
- REQUIRES_NEW：始终开启新事务。如果没有事务则开启新事务，如果有事务则挂起原有事务开启新事务。
- SUPPORTS：支持事务。如果没有事务则以非事务运行，如果有事务则加入事务。
- NOT_SUPPORTS：不支持事务。如果没有事务则以非事务运行，如果有事务则暂停事务。
- MANDATORY：强制事务。如果没有事务则抛出异常，如果有实物则加入事务。
- NEVER：不允许事务。如果没有事务则以非事务运行，如果有事务则抛出异常。
- NESTED：嵌套事务。如果没有事务则开启新事务，如果有事务，则新事务嵌套原有事务，但嵌套事务回滚不影响父事务，但父事务回滚影响嵌套事务。

### 4.5 Spring之Bean循环依赖问题

循环依赖是指：多个Bean之间相互依赖，形成了循环引用的情况，Spring在初始化无法注入依赖对象，导致无法正常启动。

常规开发中，设计良好的代码是不会产生循环依赖的问题。最好的解决方案是**重新进行设计**，其次可以使用 **@Lazy** 懒加载来解决。

### 4.6 Spring之Bean作用域

作用域对于Spring中的Bean而言，决定了Bean可以被使用的范围。

- Singleton：默认作用域，单例。全局仅有一个Bean实例。
- Prototype：原型。每个请求都会生成新的Bean实例。
- Request：请求。每个Http请求都会生成新的Bean实例。
- Session：会话。每个Http会话中，都会生成新的Bean实例。
- Application：应用。ServletContext生命周期中，仅有一个Bean实例。

### 4.7 SpringMVC执行流程

直接上图

![SpringMVC执行流程](https://img-blog.csdnimg.cn/78e4c9b4685c4ac9a10ef96aafdaba53.png#pic_center)

### 4.8 SpringCloud之组件

SpringCloud的任务：解决分布式系统中的常见问题，如`服务发现`、`负载均衡`、`配置管理`、`熔断器`等等。

原生SpringCloud常用的组件：`Eureka:服务发现和注册中心`、`Ribbon:负载均衡组件`、`Feign/OpenFeign:声明式HTTP客户端`、`Hystrix:熔断器组件，处理服务故障等问题`、`Spring Cloud Gateway:API网关，处理API请求的路由转发、权限校验、监控、限流等等`、`Spring Cloud Config:分布式配置管理`、`Spring Cloud Security:安全相关，Oauth2的认证`

就国内目前主流的SpringCloud架构设计，不会全部选择原生的组件，基本上采用如下：

- Nacos：服务发现、注册中心、配置中心
- Ribbon/LoadVkabcer：负载均衡组件
- Hystrix/Sentinel：熔断器组件
- Seata：分布式事务管理
- Dubbo：RPC框架

### 4.9 SpringCloud Ribbon和Nginx的区别

这两者都有的一个功能为：`负载均衡`，但是它们的区别在于：

- SpringCloud Ribbon的负载均衡位于客户端，负载均衡逻辑集成在服务消费者，**在客户端选择需要调用的服务提供者**，实现负载均衡。
- Nginx的负载均衡为于服务端，负载均衡逻辑集成在服务提供者，**在客户端发起请求后，通过请求转发**实现负载均衡。

### 4.10 SpringCloud之Ribbon组件

`SpringCloud Ribbon`组件是一种`客户端负载均衡`组件，其实现原理为：

**通过注册中心，将可用服务列表拉取至每一个客户端，客户端的负载均衡组件会根据策略选择具体的服务IP:端口，最后通过HTTP请求服务获取响应。**

了解了原理，那么Ribbon组件的核心就呼之欲出了：`负载均衡算法`。它提供了多种的负载均衡算法，有：`轮询`、`权重`、`随机`、`加权随机`、`加权轮询`等，具体查看实现`IRule`接口下的`AbstractLoadBalanceRule`。

- 轮询：RoundRobinRule ：按照一定顺序依次调用服务实例。
- 权重：WeightedResponseTimeRule：根据响应时间分配一个权重，时间越长，权重越小。
- 随机：RandomRule：从服务列表中随机选择。

### 4.11 SpringCloud之Sentinel组件

SpringCloud中，早期使用`Hystrix`进行限流、熔断，但其控制台不完善，缺陷多，因此Sentinel作为其同类型组件，被各大公司推荐使用。

并且其在`限流`、`熔断降级策略`相较于`Hystrix`的`基于失败比率`进行降级，Sentinel的熔断降级策略`基于慢调用比例或异常比例`，限流策略为`基于QPS，基于调用关系的限流`，比`Hystrix`更加多样化。

### 4.12 SpringCloud之服务通信方式

1. RESTful调用

基于SpringMVC，将接口暴露为HTTP接口，服务调用端通过HTTP调用实现服务通信。

2. Feign客户端调用

通过创建`一个接口`，配合`@FeignClient`注解，`Feign`组件可用自动处理请求的发送和结果的映射。由于SpringCloud对Feign进行了集成，因此这种服务通信方式较为流行。

3. SpringCloud Gateway

通过网关进行统一的API管理，根据不同的请求进行路由，将请求路由到不同的后端服务上。通过网关，能够实现`负载均衡`、`统一授权`、`流量过滤`、`限流降级`等等功能。

### 4.13 SpringCloud之Hystrix

原理和电路系统中的断路器类似：当某个部分发生故障时，断路器会切断服务之间的调用，防止故障扩散。

Hystrix断路器主要有三种状态：

- 关闭：默认情况下断路器是关闭状态；每当错误发生时，内部计数器累加依次，当计数器到达`阈值`时，断路器`开启`，同时会启动一个`计时器`，一旦时间到计时器设定时间，进入`半开启`状态。
- 开启：开启时，任何请求都会`被拒绝并抛出异常`。
- 半开启：断路器能够允许部分请求，如果部分请求还是发生错误，那么断路器会恢复`开启`，并重新计时；如果部分请求`都成功`，那么断路器会进入`关闭`，并重置所有计数器。

这里面开启断路器有个概念：`阈值`。
主要为：
1、一定时间内，请求数量超过阈值，则会进行评估是否需要开启断路器。
2、一定时间内，请求失败占比超过阈值，断路器会开启。

**Hystrix提供了两种主要的隔离策略控制服务之间的交互：线程池隔离、信号量隔离。**

- Hystrix推荐的隔离策略为：线程池隔离。每一个依赖服务调用，都从线程池中获取一个单独线程中执行，如果线程池满，则新的请求会被`立即拒绝`。
- 信号量隔离：使用Java的信号量限制并发访问的数量，当请求达到信号量的限制时，新的请求会被`立即拒绝`。

## 五、MySQL

### 5.1 MySQL数据存储

#### 5.1.1 数据库存储引擎

用于存储、处理、保护数据的核心服务。

常见有MyISAM、InnoDB、Memory等。MySQL中，存储引擎是基于`表`的。

其中，Memory引擎的数据存储基于内存，由于内存速度快的原因，因此该引擎查询性能高。

#### 5.1.2 MyISAM和InnoDB

MySQL5.5之前版本默认存储引擎为：`MyISAM`，5.5及其之后版本默认存储引擎为：`InnoDB`。

- MyISAM：非聚集索引，适合查询和插入的操作
- InnoDB：聚集索引，适合频繁修改和涉及事务相关操作

#### 5.1.3 MySQL一条SQL语句执行过程

`select * from user where name = 'test' and tel = '10001'`

该语句执行过程如下：

1. 通过`连接器`，将查询`客户端`与`MySQL`连接，并进行`验证`、`权限`等相关校验
2. 检查是否开启`查询缓存`，若开启`查询缓存`，则进行匹配，若命中缓存中相同的SQL语句，则直接返回`缓存`中的查询结果
3. `缓存`中不存在时，进入`解析器`中，分析SQL语句（语义分析、语法分析），生成`解析树`，再通过`预处理器`进一步检查`解析树`
4. `解析树`交给`优化器`进行分析，尝试优化SQL，生成执行计划
5. 最终通过`执行器`执行SQL语句，`执行器`根据不同的`存储引擎`执行SQL语句，最终返回响应结果。（若开启`缓存`，则存入缓存中）

### 5.2 数据库事务

#### 5.2.1 何为数据库事务

数据库事务：访问操作数据的一个数据库操作序列，一系列操作要么全部成功，要么全部失败，是一个不可分割的工作单位。

事务具有ACID属性：
1. A（Atomicity）原子性：事务作为一个整体，对数据库的操作要么全部执行、要么全部不执行。
2. C（Consistency）一致性：事务确保一个一致的状态转变为另一个一致的状态。
3. I（Isolation）隔离性：多个事务并发执行时，一个事务的执行不应该影响其他事务的执行。
4. D（Durability）持久性：事务一旦提交，数据的修改就应该永久保存在数据库中。

#### 5.2.2 数据库事务中的脏读、幻读、不可重复读

1. 脏读：`读到了其他事务还未提交的数据`。

脏读案例：A事务进行数据库修改，改变了某项数值，但还未提交；B事务进行数据库读取，读取到了A事务所改变的数值；此时A事务因某种原因导致事务回滚，改变的数值无效，B事务所读取的数值则是一种错误。

2. 幻读：`事务做范围查询时，另一个事务对范围内新增或删除操作，导致范围查询的结果不一致`。（幻读是不可重复读的特殊场景）

幻读案例：A事务对数据进行了全部数据行修改，B事务对数据进行新增数据；此时A事务发现全部数据行修改后，仍有未修改的数据行。

3. 不可重复读：`对某数据进行读取时，有其他事务对数据进行了修改，导致二次读取不一致`。

不可重复读案例：A事务对数据进行多次查询，B事务对数据进行了修改，导致A事务多次查询的结果不一致。

#### 5.2.3 InnoDB引擎解决脏读、幻读、不可重复读

InnoDB引擎下，通过MVCC解决脏读和不可重复读；通过MVCC+间隙锁解决幻读。

- 脏读：在事务隔离级别为`RC(Read Committed)读已提交`时，InnoDB获取当前最新的全局事务ID，InnoDB会检查每个数据行的版本，确保版本每个数据行的版本`小于等于`当前全局事务ID，这样就避免了`脏读`。
- 不可重复读：在事务隔离级别为`RR(Repeatable Read)可重复读`时，InnoDB会在使用快照读时，第一次读取生成`Read View`，后续的快照读都是使用同一个`Read View`。
- 幻读：在事务隔离级别为`RR(Repeatable Read)可重复读`时，基于MVCC+间隙锁，某种程度上能够避免幻读的发生，但没有办法完全避免，当一个事务发生当前读的时候，还是会导致幻读的发生。

> MVCC:多版本并发控制。MySQL中，通过`Read View`+`Undo Log`实现，`Undo Log`保存历史快照，`Read View`决定读取哪个快照。

#### 5.2.4 事务隔离级别

- 读未提交（RU，Read UnCommitted）：最低的隔离级别，可以读到其他事务未提交的数据，会存在幻读、脏读、不可重复读。
- 读已提交（RC，Read Committed）：读取其他事务已提交的数据，能够解决脏读的问题。
- 可重复读（RR，Repeatable Read）：能够解决脏读、不可重复读的问题。
- 串行化读（Serializable）：最高的隔离级别，能够解决脏读、不可重复读、幻读的问题。

#### 5.2.5 Select会用到事务吗

会。即使没有明确的开启事务语句，InnoDB也会自动开启一个隐式事务。

#### 5.2.6 MySQL默认隔离基本为RR，为何大厂都要默认改为RC

MySQL之所以默认隔离级别为：RR，是由于历史statement格式的Bin-log日志，在主从同步时，RC隔离级别会存在问题，因此默认为RR。

大厂之所以将默认RR更改为RC，是由于随着隔离级别的提高，锁的增加，相对应的并发度会更加受到限制。对于互联网项目而言，高并发项目更愿意选择更低级别的隔离级别RC，以降低系统发生死锁问题。

#### 5.2.7 MySQL行级锁——Record Lock、Gap Lock、Next-Key Lock

- Record Lock：记录锁；锁的是：`索引记录`。
- Gap Lock：间隙锁，锁的是：`索引记录之间的间隙`。
- Next-Key Lock：是以上两种的组合，同时锁`索引记录`与`索引记录之间的间隙`。范围为`左开右闭`。

**Gap Lock和Next-Key Lock只有在InnoDB的RR隔离级别中才会生效。**

### 5.3 InnoDB索引

#### 5.3.1 InnoDB索引数据结构

常见：`B+树索引`、`Hash索引`。`B+树索引`是主流、高效的索引，分为`聚集索引`和`非聚集索引`。

#### 5.3.2 B+树索引的特点

- `B+树`是一棵`平衡树`，根节点到每个叶子节点的长度相同，因此查找效率高。
- `B+树`的所有关键字信息都在叶子节点上，非叶子节点不存储数据，因此范围查询只需遍历叶子节点。
- `B+树`的所有叶子节点都按关键字大小顺序存放，因此根据关键字排序效率较高。
- `B+树`的叶子节点之间通过双向链表链接，方便进行范围查询。

#### 5.3.3 B+树索引和Hash索引区别

Hash索引是通过哈希函数计算后得到`桶的编号`，然后将`桶`内的记录保存在链表或树结构中，因此Hash索引适合与`等值查询`。

同样的，Hash索引维护成本较低，只需简单的增加、删除链表中的记录；B+树索引则需要调整索引结构，并且可能需要`页分裂`或`页合并`等操作。

#### 5.3.4 唯一索引允许有NULL值吗

允许，并且允许有多个NULL值的存在。这是由于NULL被认为是`未知`的，因此NULL可能等于NULL，也可能不等于NULL，所以允许多个NULL值存在。

#### 5.3.5 最左匹配原则

因为索引底层是B+树索引，联合索引的情况下，在构造B+树时，会按照左边的key进行排序，左边key相同时，再往下一个key进行排序。所以通过索引查询时，需要遵循`最左匹配原则`，否则`查询不走索引`。

#### 5.3.6 一定要遵循最左匹配原则吗

在MySQL8.0.13版本中，引入了`索引跳跃扫描`，它支持在`不符合最左前缀原则下`，依然能够使用联合索引。

`索引跳跃扫描`原理：
给定联合索引`idx(a1,a2)`，其SQL为：`select a1,a2 from a where a2= 40`。
`索引跳跃扫描`会将a1的唯一值逐个取出，与a2构造为符合最左前缀原则，最后将结果合并返回，如：

```sql
select a1,a2 from a where a1=1 and a2=40 
union
select a1,a2 from a where a1=2 and a2=40
...
```

> 这种`索引跳跃扫描`的技术，在于a1的值的区分度，区分度高数据多则MySQL优化器不一定会选择`索引跳跃扫描`技术。
> 还有其他限制条件，诸如：不能多表join、不能使用Group By或Distinct语句等

### 5.4 SQL优化

#### 5.4.1 执行计划

MySQL执行计划通过`explain`进行分析。

```text
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+--------------------------+                                           
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                    |                                           
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+--------------------------+                                           
|  1 | SIMPLE      | t1    | NULL       | ref   | idx_t         | idx_t    | 4       | const|   80 |   100.00 | Using index              |       
```

- id: 操作的唯一标识。每个操作都有唯一的id。
- select_type: 操作的类型。SIMPLE、PRIMARY、SUBQUERY、UNION。
- table: 操作的表。
- partitions：操作涉及的分区。
- type: 查询所使用的索引类型。ALL、index、range、ref、eq_ref、const、system。
- possible_keys: 可能使用的索引。
- key: 所使用的索引。
- key_len: 索引的长度。越短效率越高
- ref: 哪些列或常量被用来与key列中命名的索引进行比较。
- rows: 扫描的行数。
- filtered: 过滤掉的行数占扫描行数的百分比。
- Extra： 其他信息。`Using index`、`Using filesort`、`Using temporary`

Extra其中的信息：

1. Using where：表示 MySQL 将在存储引擎检索行后，再进行条件过滤（使用 WHERE 子句）；查询的列未被索引覆盖，where筛选条件非索引的前导列或者where筛选条件非索引列。
2. Using index：：表示 MySQL 使用了覆盖索引（也称为索引覆盖）优化，只需要扫描索引，而无需回到数据表中检索行；
3. Using index condition：表示查询在索引上执行了部分条件过滤。这通常和索引下推有关。
4. Using where; Using index：查询的列被索引覆盖，并且where筛选条件是索引列之一，但不是索引的前导列，或者where筛选条件是索引列前导列的一个范围
5. Using join buffer：表示 MySQL 使用了连接缓存；
6. Using temporary：表示 MySQL 创建了临时表来存储查询结果。这通常是在排序或分组时发生的；
7. Using filesort：表示 MySQL 将使用文件排序而不是索引排序，这通常发生在无法使用索引来进行排序时；
...

#### 5.4.2 大规模的数据库系统如何优化

1. 硬件优化
2. 数据库表结构优化、旧数据归档
3. SQL优化
4. 索引优化
5. 缓存机制
6. 负载均衡、读写分离
7. 分区分片
8. 监控、备份

## 六、计算机基础

### 6.1 TCP和UDP是什么

TCP：Transmission Control Protocol 传输控制协议，需要建立连接后才能进行数据传输的协议。有**3次握手连接**和**4次挥手断开**。由于这样的连接、断开控制，因此TCP是一种**速度相对慢**但**可靠**的传输协议。

UDP：User Dadagram Protocol 用户数据报协议，不需要建立连接即可进行数据传输。由于不需要建立连接，因此UDP是一种**速度相对快**但有**数据丢包风险**的传输协议。

都是OSI网络七层模型中，位于**传输层**的网络传输协议。

为了更好理解TCP与UDP，看看日常使用中这两种传输协议的应用。

常见的TCP应用诸如：**电子邮箱点对点发送、文件传输**

常见的UDP应用诸如：**王者荣耀实时对抗、直播数据推送**

### 6.2 OSI网络七层模型

OSI：Open System Interconnection 开放系统互联。

OSI七层模型是计算机网络中通信协议的分类

- **物理层：规定传输介质的传输方式**。最基础的一层，信号、介质是这一层的概念。
- **数据链路层**：在**物理层**上，建立数据链路，进行数据的处理，将物理层的数据传入下一层：网络层。
- **网络层**：解决数据在网络中传输的问题，寻址、路由选择是这一层的概念。
- **传输层**：解决数据端对端的传输问题，传输控制、流量控制是这一层的概念。
- **会话层**：解决不同计算机之间会话管理的功能。
- **表示层**：解决数据格式的转换，如数据转为JPEG、数据加密解密等。
- **应用层**：多数程序员处于这层，解决应用程序交互等。

## 七、Nacos

### 7.1 什么是Nacos

Nacos是阿里巴巴开源的一款动态服务发现、配置管理、服务治理平台，与Spring Cloud深度集成。

- 动态服务发现：应用系统可以将服务注册到Nacos注册中心，通过Nacos实现动态配置和负载均衡，实现服务高可用。
- 配置管理：应用系统可以将配置信息存储到Nacos配置中心，通过Nacos实现动态管理配置，实现应用动态调整和部署。
- 服务治理：Nacos可以对注册的服务进行健康监测、故障转移、服务限流、熔断降级等治理，提高应用程序的可靠性。

### 7.2 Nacos是AP还是CP

> CAP理论：一个分布式系统最多只能满足CAP中的两项。
> C：一致性；A：可用性；P：分区容错性

**Nacos支持AP和CP两种模式。** 默认为AP模式，不保证强一致性，保证Nacos的高可用和可伸缩性。

具体要选择什么样的模式根据业务进行选择。

如金融、支付等需要强一致性的业务场景，则使用CP。

如网站、游戏等需要高可用，只需要保证最终一致性的业务场景，则使用AP。

### 7.3 Nacos如何实现配置变化客户端能够感知

在早期Nacos1.x版本中，客户端使用`长轮询`机制，主动去获取配置中心是否有变化。
在Nacos2.x版本中，客户端使用`gRPC长连接`机制，配置中心若有变化则会推送给客户端。

## 八、MyBatis

### 8.1 MyBatis和Hibernate有何不同

1、Hibernate是全自动ORM框架，较为复杂，无需感知SQL逻辑。而MyBatis则是半自动ORM框架，较为简单高效，具体的SQL逻辑需要开发者自行编写，能够满足对于特殊SQL的编写、优化的操作。
2、性能要求不高的系统，推荐使用Hibernate。性能要求高，响应快的系统推荐使用MyBatis。


### 8.2 MyBatis实现字段映射的过程及原理

MyBatis实现字段映射的代码主要在`ResultSetHandler`类中，将JDBC ResultSet转为Java对象，并进行字段映射。

步骤如下：

- 1. MyBatis通过JDBC API向数据库发送SQL语句，获取查询结果集（ResultSet）。
- 2. MyBatis遍历ResultSet的数据，根据`Java对象属性名和查询结果列名进行匹配`；如果不完全一致，通过`使用别名，或ResultMap进行映射`；特殊字段则通过自定义的`TypeHandler`实现。
- 3. 最终，遍历完成后，封装成一个List集合，返回给用户使用。

### 8.3 MyBatis中#和$符号区别

这两者都是进行动态参数替换的符号，但是在`预编译处理中`是不一样的处理方式。

- `#的预编译处理`：在预编译阶段，参数以`?`进行替代，可以`有效避免SQL注入`。
- `$的预编译处理`：在预编译阶段，MyBatis会将其视为字面量，在构建SQL时`直接替换成参数的实际值`，这会导致SQL注入的风险。

### 8.4 MyBatis中插件

#### 8.4.1 MyBatis插件的运行原理

关键接口为：`Interceptor：拦截器接口`、`Invocation：调用接口`、`Plugin：插件接口`

流程如下：
- 将所有实现Interceptor接口的插件初始化。
- 将所有插件和原始的Executor对象封装为一个`InvocationChain`对象。
- 每次执行SQL语句时，通过`InvocationChain`对象的责任链模式，依次调用所有插件的intercept方法，实现对SQL语句的拦截和修改。
- 最后将修改后SQL语句交给原始的Executor对象执行，并返回执行结果。

#### 8.4.2 MyBatis插件之PageHelper

PageHelper是MyBatis中提供的分页插件，用来做`物理分页`。

当通过`startPage(int pageNum,int pageSize)`设置分页参数后，在执行具体查询代码之前，会从`ThreadLocal`获取分页参数信息，进行分页算法，计算`需要返回的数据块的起始位置和大小`，然后修改`SQL语句`，动态拼接上limit语句；查询结束后清除`ThreadLocal`分页参数。


## 九、Redis

### 9.1 Redis的集群模式

为了在分布式环境中实现高可用和数据备份，Redis有3种集群模式：主从复制模式（Master-Slave）、哨兵模式（Sentinel）、Redis Cluster模式

#### 9.1.1 主从复制模式

该模式主要为了**解决单点故障的问题**。该模式中，有一个主节点（Master）和一个或多个从节点（Slave）。

主节点：负责处理所有**读写操作**。

从节点：负责复制主节点的数据，并且只能处理**读操作**。

**该模式的故障转移需要手动实现，将一个从节点升级为主节点。**因此，该模式在主节点和从节点宕机时，会导致**客户端读写失败**，并且主节点数据如果没有及时复制到从节点，会导致**数据不一致**。

#### 9.1.2 哨兵模式

为了解决**主从复制模式**的手动故障转移问题，Redis引入了**哨兵模式**。该模式在**主从复制模式**的基础上，加入了**哨兵节点**，**哨兵节点**用于监控主节点和从节点状态，定期向所有主节点和从节点发送PING命令，在指定时间内未收到PONG响应，则哨兵节点会将未收到响应的节点标记为**主观下线**；如果主节点被多个**哨兵节点**标记为**主观下线**，则主节点会被标记为**客观下线**。当主节点发生故障时，哨兵节点自动进行故障转移（**选择一个从节点升级为主节点，【发布订阅】通知其他从节点和应用程序更新**）。

因此，**哨兵模式**下，为了保证**哨兵节点**的高可用，需要部署**多个哨兵节点**。至此，哨兵模式解决了主从复制模式下无法自动故障转移的问题。

#### 9.1.3 Redis Cluster 模式

这是Redis中推荐的分布式集群解决方案，它将数据自动**分片**到**多个节点**上，每个节点负责一部分数据。一样是采用**主从复制模式**，每个**分片**都有一个主节点和多个从节点。Redis Cluster有自动检测节点故障的能力，当某个节点不可达时，会将该节点**尝试**标记不可用，并从其他可达的从节点提升一个新的**主节点**。

Redis数据分片：将一个Redis数据集分割成多个部分，分布存储在不同的Redis节点的技术。可以将一个单独的Redis数据库扩展到多个机器上，极大提升了Redis集群的可拓展性。数据分片实现方式为：**将数据按照算法将数据存放在哈希槽（hash slot）分配到不同节点上**，当客户端需要某个数据时，**计算出数据所处节点**，访问到节点进行数据操作。

具体的实现为：将数据集分为16384个槽，**每个节点可以负责多个槽**。当需要存取Key时，Redis根据**CRC16算法的结果对16384取余**，计算出Key对应的**槽**，通过**槽**获取对应的节点，接着访问对应节点对Key进行操作。


在Redis Cluster模式下，**数据被分片存储到不同节点上**，，每个节点都可以单独对外提供服务，**不存在单点故障的问题**；并且多个节点的分散数据，极大提高了Redis的**性能和吞吐量**；支持横向扩展，在高峰期能够添加更多节点以提高性能，具有**高可扩展性**。


### 9.2 Redis通信协议

Redis自行提供了一种通信协议：**RESP（Redis Serialization Protocol）**，RESP基于TCP协议，采用**请求/响应模式**，每个请求包含多个参数，**以命令名称作为第一个参数**，请求/响应都以：`\r\n`作为分隔符。

```
RESP格式：

*<number of arguments>\r\n
$<length of argument 1>\r\n
<argument data>\r\n
...
$<length of argument N>\r\n
<argument data>\r\n

RESP请求案例(设置一个名为testkey的键，值为testvalue的请求)：
*3\r\n
$3\r\n
SET\r\n
$7\r\n
testkey\r\n
$9\r\n
testvalue\r\n

RESP响应案例（返回+OK操作成功）
+OK\r\n
```

### 9.3 Redis为何快

- 1、 最重要的一点：**基于内存**，内存相较于其他存储读写的速度是最快的。
- 2、 **单线程模型**：所有操作在一个线程内完成，无需**线程切换/上下文切换**。
- 3、 **多路复用I/O模型**：在单线程模型下，采用I/O多路复用的技术，实现单线程同时处理多个客户端的能力。
- 4、 **内部数据结构实现设计极为高效**。
- 5、 Redis6.0版本引入了多线程。（只针对于**网络处理**）

### 9.4 Redis的数据类型

常用的为：`String`、`Set`、`ZSet`、`List`、`Hash`

在Redis中，由于C语言的字符串识别到`\0`则认为字符串结束，导致Redis在内部自己定义了`SDS（Simple Dynamic Strings）简单动态字符串`，以满足存储任何字符的需求。

在Redis中，`ZSet`的实现也是颇有意思，其内部维护了一个有序的字典【成员member、double类型的分值】，因此ZSet的数据类型常被用于排行榜。

### 9.5 Redis的持久化机制

- RDB：将Redis内存的数据**定期**保存到磁盘上。因此其缺点就是在**两个定期的区间内**若发生异常情况，区间内的数据**可能会丢失**。
- AOF：将Redis对数据的写操作追加至AOF文件，恢复时执行AOF文件即可。因此其缺点就是需要实时写入AOF文件，导致负载相对于RDB较高，但是安全性较RDB也更加安全。

Redis支持将以上两种持久化机制一起使用，支持混合持久化，这样能够使数据安全性得到提升。

### 9.6 Redis的过期策略

Redis采用的是：*定期删除和惰性删除*相结合的过期策略。

- 定期删除：默认**每隔100ms随机抽取一些设置了过期时间的key**，并检测是否过期，过期则删除。**占用CPU，影响Redis性能。**
- 惰性删除：在访问到过期key的时候，才会触发删除操作。**节省CPU资源，但是过期key会存在内存中，占用内存空间。**

### 9.7 Redis之内存淘汰策略

在内存被key占满之后，该如何决定哪些key被删除呢？Redis提供了多种的淘汰策略，可通过`maxmemory-policy`参数进行选择。

- noeviction:不淘汰，返回错误信息。
- allkeys-lru:从**所有key中选择最近最少使用的key**进行删除。
- volatile-lru:从**设置了过期时间的key中选择最近最少使用的key**进行删除。
- allkeys-random:从**所有key中随机选择一个key**进行删除。
- volatile-random:从**设置了过期时间的key中随机选择一个key**进行删除。
- volatile-ttl:从**设置了过期时间的key中选择剩余时间最短的key**进行删除。
- volatile-lfu:从**设置了过期时间的key中选择访问频率最低的key**进行删除。
- allkeys-lfu:从**所有key中选择访问频率最低的key**进行删除。


来看看各大厂对于Redis淘汰策略的选择：

- 腾讯：Redis作为缓存，使用allkeys-lru。Redis作为半缓存、半持久化，使用volatile-lru。（腾讯云默认noeviction，对于腾讯云的实例需要手动修改下内存淘汰策略）
- 阿里：默认volatile-lur。

### 9.8 缓存击穿、缓存穿透、缓存雪崩

- 缓存击穿：某一个key的**缓存过期**时，大量请求同时访问key，造成缓存失效直接访问数据库。
- 缓存穿透：某一个key没有缓存数据，**数据库也没有数据**，导致直接访问数据库，缓存形同虚设，被穿透一般。
- 缓存雪崩：大量key同一时间过期或缓存服务器宕机，导致大量请求直接访问数据库。
