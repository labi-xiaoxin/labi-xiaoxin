# Java面试知识库

## 一、Java基础

### 1.1 Java是个面向对象的语言，如何理解面向对象呢？

- 面向对象的三大基本特征：`继承、封装、多态`
  - `继承`：子类继承父类，父类的属性和方法继承到子类。
  - `封装`：将现实世界的事物抽象为一个Java类，该类封装了事物的属性、方法。
  - `多态`：子类继承父类，可以通过`重写(overwrite)`父类方法，实现一个方法具有不同的实现。
- 面向对象的五大基本原则：`单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则`
  - `单一职责原则`：一个类只负责一件事。提高代码可维护性。
  - `开放封闭原则`：对扩展开放，对修改封闭。提高代码可扩展性。
  - `里氏替换原则`：子类必须能够替换其基类。提高代码灵活性。
  - `依赖倒置原则`：方法依赖于抽象接口，而不是具体的实现。降低系统的耦合。
  - `接口隔离原则`：将一个复杂臃肿的接口拆分为更小、更专注的接口。提高代码的灵活性和稳定性。

### 1.2 Java的继承

- Java只允许多实现，不允许多继承
- 多继承在C++中存在`菱形继承`的问题，Java为了避免该类问题，不允许多继承。
- Java允许多实现，为了避免`菱形继承`的问题，实现的接口如果方法存在重复，就必须`重写(overwrite)`重复的方法。
- Java的接口和抽象类的区别
  - Java8中接口有default方法，其余只能为抽象方法，没有实现代码。而抽象类可以有实现代码。
  - 接口不可以有构造器，抽象类可以有。
  - 接口被实现，抽象类被继承。
  - 接口只能使用`public`修饰符。

### 1.3 Java的基本类型与包装类型

- 基本类型：`byte、short、int、long、char、float、double、boolean`
- 包装类型：`Byte、Short、Integer、Long、Character、Float、Double、Boolean`
- 包装类型存在的意义：Java是面向对象的语言，很多地方需要使用包装类型而不是基本类型。
- 基本类型默认值为：`0、false、\u0000`,包装类型默认值为：`null`
- Java为了便于开放人员，提供了`自动装箱`、`自动拆箱`的功能
  - `自动装箱`：自动将基本类型转换对应包装类型。通过包装类型的`valueOf()`方法
  - `自动拆箱`：自动将包装类型转换对应基本类型。通过包装类型的`xxxValue()`方法

### 1.4 Java用什么适合存储金额的类型

Java中，`float`和`double`都是浮点数，浮点数在计算机中都是近似值，因此使用这两个类型存储金额的话，容易产生`计算错误`的问题。
因此，Java中提供了`BigDecimal`进行精确运算。

- `BigDecimal`中的等值比较应使用`compareTo`，而不是`equals`方法。因为`equals`比较`value(值)和scale(标度)`，0.1与0.10的value是一样的，而scale的值是不一样的。
- `BigDecimal`需要准确的运算，那么`BigDecimal(double)`和`BigDecimal(String)`对比，`BigDecimal(String)`的值是准确的，而`BigDecimal(double)`由于double是近似值，因此值是不准确的。

### 1.5 String、StringBuilder、StringBuffer

- 可变性：String不可变、StringBuilder/StringBffer是可变的。
- 线程安全：StringBuffer、String是线程安全，StringBuilder非线程安全。

### 1.6 Java的动态代理

- 动态代理：在运行时动态地创建代理对象，并处理代理方法调用的机制。
- 动态代理用途：各种框架中，在运行期生成代理类，如过滤器、拦截器等。
- Java中的动态代理：Spring AOP的动态代理有两种方式：`JDK动态代理`和`Cglib动态代理`
  - `JDK动态代理`：通过反射接收被代理的类。（要求必须要实现一个接口）
  - `Cglib动态代理`：第三方类库，通过继承的方式做动态代理。

### 1.7 什么是AIO、BIO、NIO

- `AIO`：`Asynchronous I/O`异步非阻塞I/O模型，操作后会回调通知调用方。
- `BIO`:`Blocking I/O`同步阻塞I/O模型，一直阻塞，直到处理完成。
- `NIO`:`Non-Blocking I/O`同步非阻塞I/O模型，不阻塞，进行其他操作，定时轮询检查。

## 二、Java集合

### 2.1 Java中的集合类

- 单一元素的集合：`Set、List、Queue、Stack`
- 键值对的集合：`Map`

`Set、List、Queue`都是`Collection`子接口。

### 2.2 Java集合中的Set

Set在Java体系中，根据实现方式的不同，分为：`HashSet`和`TreeSet`。

#### 2.2.1 HashSet

HashSet的实现是通过哈希表，底层基于`HashMap`来存储数据。

- 当添加元素时，首先通过算法计算元素的存储位置，如果位置为空则添加；否则用`equals`判断元素是否相等，相等不添加，不相等则再找个位置进行添加。

HashSet是`线程不安全`，`无序`，`不可重复`。

#### 2.2.2 TreeSet

TreeSet的实现是通过红黑树，底层基于`TreeMap`的`keySet()`。

TreeSet是`线程不安全`，`有序`，`不可重复`。

### 2.3 Java集合中的List

List在Java体系中，根据实现方式的不同，分为：`ArrayList`、`LinkedList`和`Vector`.

#### 2.3.1 ArrayList

实现`List`接口，底层是基于`数组`实现，因此具有：`查询快`、`高效随机访问`、`空间占用小`的优点。

##### 2.3.1.1 ArrayList扩容机制

ArrayList是基于`数组`实现，`数组`为定长的，那么ArrayList的自动扩容机制：
1、 检查新元素的添加是否会超过数组的长度，如果超过则进行2
2、 设置`新数组`新的容量为原来的`1.5`倍，将`原数组`复制到`新数组`
3、 扩容完成

#### 2.3.2 LinkedList

实现`List`接口，底层是基于`双向链表`实现，因此具有：`插入删除快`的优点，缺点：`低效率随机访问`、`每个节点前后占用空间，空间占用大`

#### Vector

实现`List`接口，类似于`ArrayList`，底层也是基于`数组`实现，不同的是`Vector`增加了线程安全（`synchronized`）的实现，效率相对来说`较低`。

**多线程环境下，Vector并不能够保证复合操作的线程安全。**

### 2.4 Java集合中的Map

Map在Java体系中，常见的实现类有：`HashMap`、`ConcurrentHashMap`、`LinkedHashMap`、`TreeMap`、`HashTable`。

#### 2.4.1 HashMap

**HashMap非线程安全！！！**

默认初始容量：16，默认加载因子：0.75。

##### 2.4.1.1 HashMap数据结构

HashMap的数据结构在不同JDK版本下，有不同的数据结构。

- JDK1.7版本：`数组、链表`
- JDK1.8版本：`数组、链表、红黑树`

数组的特性：`查找快、插入删除慢`
链表的特性：`查找慢、插入删除快`

因此HashMap将`数组`和`链表`组合，充分发挥它们的优点，`数组`的每个成员是个`链表`。这样就能够解决hash冲突时产生的问题，这也叫：`链地址法`。

后来1.8之所以加上`红黑树`的数据结构，是因为在某些极端情况下，`数组`的某个成员的`链表`的长度过程，影响`插入、删除`的效率，在`链表`长度大于8时，会进行`树化`操作，将`链表`转换为`红黑树`。

##### 2.4.1.2 HashMap的get/put方法

- get
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则返回Null；否则进入3
  - 3、遍历对应位置的链表（或红黑树），当键匹配上时，返回该键值对。

- put
  - 1、计算出所给的键的hash值，计算对应的位置
  - 2、对应的位置如果元素为空，则存储该键值对；否则进入3
  - 3、对应的位置如果元素不为空，则遍历查找是否有键相等的元素；如果有相等元素，则更新旧值为新值，`返回旧值`；否则进入4
  - 4、对应的位置元素不为空，且没有相等元素，将键值对插入对应`链表`或`红黑树`（如果链表满了，则自动转换为红黑树）
  - 5、插入成功返回被替换的值；插入失败返回null
  - 6、判断当前集合是否需要扩容，需要则扩容，否则结束

#### 2.4.2 ConcurrentHashMap

**ConcurrentHashMap是线程安全类，相较于HashTable同为线程安全类，性能较高！！！**

ConcurrentHashMap不允许null值，在多线程环境下，如果允许null值存在，那么将带来许多的`不确定性`。

默认初始容量：16，默认加载因子：0.75。

ConcurrentHashMap为保证`线程安全`，在不同JDK版本下，有不同的实现。

- JDK1.7版本：使用`分段锁`保证线程安全，ConcurrentHashMap默认情况下将hash表分为16个桶，在加锁时，仅对某个单独桶进行加锁，其他桶不受影响，因此粒度相较于使用HashTable更小，性能也更好。
- JDK1.8版本：随着`synchronized`的升级，JDK1.8对ConcurrentHashMap实现线程安全的方式也进行了修改：使用`CAS`和`synchronized`。减少内存的开销。

## 三、Java多线程

### 3.1 什么是多线程

#### 3.1.1 线程和进程

理解`多线程`前，先理解什么是线程，什么是进程。

- 进程：程序执行的一个实例，如windows下任务管理器中可看到，一个个进程。
- 线程：进程中的一个独立执行单位，一个进程可以包含多个线程。（如实例图中，vs code应用有10个线程）

![windows10任务管理器](https://cdn.jsdelivr.net/gh/labi-xiaoxin/img/202403171557810.png)

#### 3.1.2 Java中线程的6个状态

- 1、 NEW：新建了线程，线程处于未执行`.start()`方法的状态。
- 2、 RUNNABLE：运行状态。Java中对于`READY(就绪)`和`RUNNING(运行中)`没有严格的区分，统一为`RUNNABLE`状态。
- 3、 BLOCKED：阻塞。
- 4、 WAITING：等待。
- 5、 TIMED_WAITING：超时等待。
- 6、 TERMINATED：终止。

多线程是指在一个程序中**同时**执行多个线程的能力，也就是一个进程中执行多个线程的能力。每个线程都是程序中的一个单独的执行路径，可以独立运行，但又共享相同的资源，如内存空间、文件句柄等。多线程允许程序同时执行多个任务，从而提高了程序的并发性和性能。

多线程中有个重要的概念：`上下文切换`，它的意思是指：CPU从一个线程切换到另一个线程时，保存原线程的上下文状态，恢复切换线程的上下文状态。

由于需要`保存`和`恢复`的动作，导致`多线程`的`上下文切换`不允许过多，否则容易导致`系统的运行效率降低`。

### 3.2 多线程带来的线程安全

线程安全：在多线程环境下，能够正确的处理多个线程之间的`共享变量`，使程序按照预期的结果运行。

#### 3.2.1 Java创建线程的方式

- 继承Thread类
- 实现Runnable接口
- Callable和FutureTask创建线程
- 线程池创建线程

#### 3.2.2 run/start、wait/sleep、notify/notifyAll区别

- 1、run/start
run是在单线程中运行run方法；start是启动一个线程执行run方法。

- 2、wait/sleep
sleep：不会释放对象锁，线程进入TIMED_WAITING超时等待状态，可以在任何地方使用。
wait：会释放对象锁，线程进入WAITING等待状态，只能用在`同步代码块或同步方法`。

- 3、notify/notifyAll
notify唤醒单个处于WAITING状态的线程；notifyAll唤醒所有。

#### 3.2.3 ThreadLocal是什么

用来存放私有线程的数据。

`线程间私有，线程内共享`。

#### 3.2.4 synchronized关键字

`synchronized`作为Java中一个重要关键字，用来加锁，支持：`方法加锁`、`代码块加锁`。

`方法加锁`：同步方法的常量池存在`ACC_SYNCHRONIZED`标志。通过该标志，判断是否需要获取`监视器锁`。
`代码块加锁`：同步代码块使用`monitorenter`和`monitorexit`指令实现加锁和释放锁。

#### 3.2.5 synchronized锁升级

JDK1.6及之前版本：是通过`监视器锁`实现，这时候的锁是`重量级锁`，因而早期版本JDK不推荐使用`synchronized`关键字加锁。
JDK1.6之后：引入`偏向锁`、`轻量级锁`、`重量级锁`。
锁升级的过程便是：`无锁`——> `偏向锁`——> `轻量级锁`——> `重量级锁`

##### 3.2.5.1 偏向锁

线程首次进入synchronized块时，自动由`无锁`转为`偏向锁`。当同一时间，其他线程尝试访问对象时，由于对象头中的`线程ID`不同，此时锁会升级为`轻量级锁`。

##### 3.2.5.2 轻量级锁

其他线程尝试获取轻量级锁时，会有2个步骤：
1、 对象头的Mark Word复制到线程栈中的锁记录（Lock Record）
2、 尝试替换对象头的Mark Word（通过CAS尝试）

当CAS失败时，`轻量级锁`会升级为`重量级锁`

##### 3.2.5.3 重量级锁

当锁为`重量级锁`时，对象头记录指向等待队列（等待获取重量级锁的队列）的指针。

其他线程尝试获取重量级锁时，需要先进入等待队列，等待该锁被释放。然后被JVM唤醒。

#### 3.2.6 volatile

volatile也是Java中的一个关键字，但它仅能对`变量`进行修饰。

它具有：`有序性`和`可见性`的特征。不具有`原子性`。

可见性：volatile修饰的变量每次修改都会刷入主存，因此其他线程都能够看见修改的值。
有序性：通过`内存屏障`，禁止了指令重排，因而保证了代码严格按照顺序执行。

### 3.3 Java虚拟机（JVM）

#### 3.3.1 Java平台无关性

Java有个特性叫：平台无关性。意思是在计算机上运行时，与使用的平台（windows、linux等）无关，不受不同系统的约束。

Java语言通过JVM(Java Virtual Machine)来实现这个特性。不同平台下载不同平台对应的JVM，Java语言通过JVM进行编译，编译为不同平台的二进制文件，这样就能够实现多平台运行。

#### 3.3.2 JVM运行时内存区域

JVM运行时内存区域包含：`Java堆`、`运行时常量池`、`方法区`、`Java虚拟机栈`、`本地方法栈`、`程序计数器` 

- Java堆：存储对象实例的区域，线程间共享。是内存总体最大的一块，Java中的垃圾回收也是对于堆进行垃圾回收的。
- 运行时常量池：方法区的一部分，线程间共享。存储编译阶段产生的信息，`符号引用常量`、`字面量`。
- 方法区：线程间共享，存储已被加载的：`类信息`、`常量`、`静态变量`、`即时编译的代码`
- Java虚拟机栈：线程私有，存储局部变量，每次操作方法都会创建一个`栈帧`，方法操作完成，`栈帧`弹出，数据清除。
- 本地方法栈：线程私有，本地方法类似于C语言之类的实现，本地方法栈存储本地方法的`参数`、`局部变量`等信息。
- 程序计数器：线程私有，每个线程独立维护一个程序计数器，用于`指示下一个要被执行的指令的位置`。

#### 3.3.3 什么是分代？什么是新生区？什么是老年区？

Java中分代一般是指：堆内存的分代；将堆内存`不同生命周期的对象`存储在堆内存中`不同的区域`，这就是Java中的堆内存分代。

Java根据不同生命周期，将堆内存区域划分为：`新生区（新生代）`、`老年区（老年代）`。

`新生区`：新分配的对象。其中又分为：`Eden(伊甸园)`、`From(幸存区From)`、`To(幸存区To)`。对象默认先进入Eden区，在Eden满了之后，触发GC，GC会判断对象是否存活，存活则进入`幸存区`。当`幸存区`满了之后，存活的对象进入`老年区`。

`老年区`：长期存在的对象。经过多轮的GC依旧存活的对象，进行回收时较慢。

#### 3.3.4 Java中的Stop The World

简称STW，在JVM垃圾回收时，Java只保留垃圾回收线程，其他线程均被挂起。这就是Stop The World。只有其他线程挂起，这样垃圾回收才能正常执行，否则会出现垃圾清理不完全、标记算法出现`漏标`、`多标`等问题。

#### 3.3.5 JVM垃圾回收算法盘点

- 标记-清除
最为简单的一种垃圾回收算法，标记对象为垃圾，然后清除该对象。
缺点同样也很突出：清除对象后，留下的内存空间并非连续的，会产生许多`内存碎片`。
- 标记-复制
由于`标记-清除`算法的缺点太过于突出，于是`标记-复制`算法便随之产生。将内存划分为2个区域，标记对象为垃圾，将存活对象复制到另一个内存空间（复制空间上是连续的），然后清除标记的对象。
缺点就是内存需要预留1个区域进行复制。
- 标记-整理
`标记-清除`、`标记-复制`都有明细的缺点，`标记-整理`就是结合了前两者进行设计的。
`标记-整理`分为2步骤：
- 标记：将存活对象标记
- 整理：移动存活对象，按照内存地址次序依次排列，排列完成后回收其余空间。
缺点:标记、整理耗费时间较多，性能不高。

#### 3.3.6 JVM判断对象存活

- 可达性分析算法：从一组称为GC Roots的对象开始，通过这些对象向下搜索其他对象，形成引用链。

有两次标记：
  1、 可达性分析算法标记。
  2、 `finalize()`方法是否被覆盖且没有执行过，没有执行过则会进行二次标记，然后回收。 

- 引用计数法：对象被引用时，计数器加1，引用失效时，计数器减1。基本没有使用这个算法，无法解决循环引用问题。

#### 3.3.7 三色标记算法

JVM中垃圾标记的算法，在CMS、G1等垃圾回收算法中主要使用的算法。

将对象分为3种颜色：

- 白色：没有被标记过。
- 灰色：被标记过，引用对象还没标记完。
- 黑色：被标记过，引用对象已标记完。

标记对象步骤分为三步：

- 初始标记：需要STW挂起其他线程进行标记。将根对象以及直接引用的对象标记灰色。
- 并发标记：并发标记，不需要STW挂起其他线程。从灰色对象遍历对象，遍历完成对象标记为黑色。由于是并发状态下，需要使用`写屏障（Write Barrier）`技术来保证准确性。
- 重新标记：需要STW挂起其他线程进行标记，从灰色对象遍历对象，遍历完成对象标记为黑色。

标记完成后，白色为不可达对象，正常情况下会被垃圾回收。

#### 3.3.8 JVM常见监控工具

- Jmap：JVM自带的命令行工具，可以生成JVM堆内存的dump文件，分析堆内存使用情况。
- 商业软件：JProfile：监视内存、线程、GC等信息。
- Arthas：阿里巴巴开源的Java诊断工具。

#### 3.3.9 JVM常用调参

1、 堆设置：`-Xms（堆初始大小） -Xmx（堆最大大小）`
2、 栈设置：`-Xss（线程的栈大小）`
3、 垃圾回收设置：`-XX:+UseG1GC（使用G1垃圾回收器） -XX:+UseParallelGC（使用并行垃圾回收器）`
4、 元空间设置(1.8)：`-XX:MetaspaceSize（元空间初始大小） -XX:MaxMeatspaceSize（元空间最大大小）`
5、 打印垃圾回收信息：`-XX:PrintGCDetails`
6、 内存溢出时，生成dump文件：`-XX:+HeapDumpOnOutOfMemoryError`

## 四、Spring全家桶 

### 4.1 Spring之IoC

IoC：inversion of control，控制反转。

具体到代码中的释义如下：

>代码中一个个对象的创建、管理，原先是由用户一个个`new`出来进行使用，而Spring将对象的创建、管理控制权，交由Spring容器进行管理。需要使用对象时，则通过Spring容器中获取对象即可。

这样的特性，能够极大地`降低代码的复杂度`，`无需关注引用对象的细节`，`避免重复创建对象导致空间浪费`。

### 4.2 Spring之AOP

AOP：Aspect-Oriented Programming,面向切面编程。

具体到代码中的释义如下：

>一段代码可能包含：日志打印、业务核心、接口校验、事务管理等等，其中核心便是：`业务核心`，其余功能点均是在这个`业务核心`之外的，那么就能够把其他功能看作是不同`切面`。

这样，业务代码就能够与其它不同功能的代码解耦，具体代码只专注于业务的准确性即可。

SpringAOP的实现方式有2种：`Jdk动态代理`、`Cglib动态代理`

其不同点是：**jdk动态代理只能代理有接口的类；cglib用于代理没有接口的类**。

### 4.3 Spring之Bean生命周期

>创建（实例化、初始化） ——> 使用 ——>销毁

Spring如一个世界，其中的Bean如现实世界中的人。与人类似，有着`出生`->`成长`->`死亡`的三个阶段，人的成长是一个过程，Bean的使用也是一个过程。

- Bean出生：
  - 1、实例化：Spring容器创建Bean实例
  - 2、初始化：`设置属性值->执行Aware接口方法->BeanPostProcessor前置处理->InitializingBean处理->自定义init-method方法->BeanPostProcessor后置处理`
- Bean成长
  - 1、正常使用
- Bean死亡
  - 1、销毁：自定义的destory-method方法销毁Bean

### 4.4 Spring之事务传播机制

Spring有7种事务传播机制，对应以下7种：

- REQUIRED：默认事务传播机制。如果没有事务则开启新事务，如果有事务则加入事务。
- REQUIRES_NEW：始终开启新事务。如果没有事务则开启新事务，如果有事务则挂起原有事务开启新事务。
- SUPPORTS：支持事务。如果没有事务则以非事务运行，如果有事务则加入事务。
- NOT_SUPPORTS：不支持事务。如果没有事务则以非事务运行，如果有事务则暂停事务。
- MANDATORY：强制事务。如果没有事务则抛出异常，如果有实物则加入事务。
- NEVER：不允许事务。如果没有事务则以非事务运行，如果有事务则抛出异常。
- NESTED：嵌套事务。如果没有事务则开启新事务，如果有事务，则新事务嵌套原有事务，但嵌套事务回滚不影响父事务，但父事务回滚影响嵌套事务。

### 4.5 Spring之Bean循环依赖问题

循环依赖是指：多个Bean之间相互依赖，形成了循环引用的情况，Spring在初始化无法注入依赖对象，导致无法正常启动。

常规开发中，设计良好的代码是不会产生循环依赖的问题。最好的解决方案是**重新进行设计**，其次可以使用 **@Lazy** 懒加载来解决。

### 4.6 Spring之Bean作用域

作用域对于Spring中的Bean而言，决定了Bean可以被使用的范围。

- Singleton：默认作用域，单例。全局仅有一个Bean实例。
- Prototype：原型。每个请求都会生成新的Bean实例。
- Request：请求。每个Http请求都会生成新的Bean实例。
- Session：会话。每个Http会话中，都会生成新的Bean实例。
- Application：应用。ServletContext生命周期中，仅有一个Bean实例。

### 4.7 SpringMVC执行流程

直接上图

![SpringMVC执行流程](https://img-blog.csdnimg.cn/78e4c9b4685c4ac9a10ef96aafdaba53.png#pic_center)

## 五、MySQL

### 5.1 MySQL数据存储

#### 5.1.1 数据库存储引擎

用于存储、处理、保护数据的核心服务。

常见有MyISAM、InnoDB、Memory等。MySQL中，存储引擎是基于`表`的。

其中，Memory引擎的数据存储基于内存，由于内存速度快的原因，因此该引擎查询性能高。

#### 5.1.2 MyISAM和InnoDB

MySQL5.5之前版本默认存储引擎为：`MyISAM`，5.5及其之后版本默认存储引擎为：`InnoDB`。

- MyISAM：非聚集索引，适合查询和插入的操作
- InnoDB：聚集索引，适合频繁修改和涉及事务相关操作

#### 5.1.3 MySQL一条SQL语句执行过程

`select * from user where name = 'test' and tel = '10001'`

该语句执行过程如下：

1. 通过`连接器`，将查询`客户端`与`MySQL`连接，并进行`验证`、`权限`等相关校验
2. 检查是否开启`查询缓存`，若开启`查询缓存`，则进行匹配，若命中缓存中相同的SQL语句，则直接返回`缓存`中的查询结果
3. `缓存`中不存在时，进入`解析器`中，分析SQL语句（语义分析、语法分析），生成`解析树`，再通过`预处理器`进一步检查`解析树`
4. `解析树`交给`优化器`进行分析，尝试优化SQL，生成执行计划
5. 最终通过`执行器`执行SQL语句，`执行器`根据不同的`存储引擎`执行SQL语句，最终返回响应结果。（若开启`缓存`，则存入缓存中）

### 5.2 数据库事务

#### 5.2.1 何为数据库事务

数据库事务：访问操作数据的一个数据库操作序列，一系列操作要么全部成功，要么全部失败，是一个不可分割的工作单位。

事务具有ACID属性：
1. A（Atomicity）原子性：事务作为一个整体，对数据库的操作要么全部执行、要么全部不执行。
2. C（Consistency）一致性：事务确保一个一致的状态转变为另一个一致的状态。
3. I（Isolation）隔离性：多个事务并发执行时，一个事务的执行不应该影响其他事务的执行。
4. D（Durability）持久性：事务一旦提交，数据的修改就应该永久保存在数据库中。

#### 5.2.2 数据库事务中的脏读、幻读、不可重复读

1. 脏读：`读到了其他事务还未提交的数据`。

脏读案例：A事务进行数据库修改，改变了某项数值，但还未提交；B事务进行数据库读取，读取到了A事务所改变的数值；此时A事务因某种原因导致事务回滚，改变的数值无效，B事务所读取的数值则是一种错误。

2. 幻读：`事务做范围查询时，另一个事务对范围内新增或删除操作，导致范围查询的结果不一致`。（幻读是不可重复读的特殊场景）

幻读案例：A事务对数据进行了全部数据行修改，B事务对数据进行新增数据；此时A事务发现全部数据行修改后，仍有未修改的数据行。

3. 不可重复读：`对某数据进行读取时，有其他事务对数据进行了修改，导致二次读取不一致`。

不可重复读案例：A事务对数据进行多次查询，B事务对数据进行了修改，导致A事务多次查询的结果不一致。

#### 5.2.3 InnoDB引擎解决脏读、幻读、不可重复读

InnoDB引擎下，通过MVCC解决脏读和不可重复读；通过MVCC+间隙锁解决幻读。

- 脏读：在事务隔离级别为`RC(Read Committed)读已提交`时，InnoDB获取当前最新的全局事务ID，InnoDB会检查每个数据行的版本，确保版本每个数据行的版本`小于等于`当前全局事务ID，这样就避免了`脏读`。
- 不可重复读：在事务隔离级别为`RR(Repeatable Read)可重复读`时，InnoDB会在使用快照读时，第一次读取生成`Read View`，后续的快照读都是使用同一个`Read View`。
- 幻读：在事务隔离级别为`RR(Repeatable Read)可重复读`时，基于MVCC+间隙锁，某种程度上能够避免幻读的发生，但没有办法完全避免，当一个事务发生当前读的时候，还是会导致幻读的发生。

> MVCC:多版本并发控制。MySQL中，通过`Read View`+`Undo Log`实现，`Undo Log`保存历史快照，`Read View`决定读取哪个快照。

#### 5.2.4 事务隔离级别

- 读未提交（RU，Read UnCommitted）：最低的隔离级别，可以读到其他事务未提交的数据，会存在幻读、脏读、不可重复读。
- 读已提交（RC，Read Committed）：读取其他事务已提交的数据，能够解决脏读的问题。
- 可重复读（RR，Repeatable Read）：能够解决脏读、不可重复读的问题。
- 串行化读（Serializable）：最高的隔离级别，能够解决脏读、不可重复读、幻读的问题。

#### 5.2.5 Select会用到事务吗

会。即使没有明确的开启事务语句，InnoDB也会自动开启一个隐式事务。

#### 5.2.6 MySQL默认隔离基本为RR，为何大厂都要默认改为RC

MySQL之所以默认隔离级别为：RR，是由于历史statement格式的Bin-log日志，在主从同步时，RC隔离级别会存在问题，因此默认为RR。

大厂之所以将默认RR更改为RC，是由于随着隔离级别的提高，锁的增加，相对应的并发度会更加受到限制。对于互联网项目而言，高并发项目更愿意选择更低级别的隔离级别RC，以降低系统发生死锁问题。

#### 5.2.7 MySQL行级锁——Record Lock、Gap Lock、Next-Key Lock

- Record Lock：记录锁；锁的是：`索引记录`。
- Gap Lock：间隙锁，锁的是：`索引记录之间的间隙`。
- Next-Key Lock：是以上两种的组合，同时锁`索引记录`与`索引记录之间的间隙`。范围为`左开右闭`。

**Gap Lock和Next-Key Lock只有在InnoDB的RR隔离级别中才会生效。**

### 5.3 InnoDB索引

#### 5.3.1 InnoDB索引数据结构

常见：`B+树索引`、`Hash索引`。`B+树索引`是主流、高效的索引，分为`聚集索引`和`非聚集索引`。

#### 5.3.2 B+树索引的特点

- `B+树`是一棵`平衡树`，根节点到每个叶子节点的长度相同，因此查找效率高。
- `B+树`的所有关键字信息都在叶子节点上，非叶子节点不存储数据，因此范围查询只需遍历叶子节点。
- `B+树`的所有叶子节点都按关键字大小顺序存放，因此根据关键字排序效率较高。
- `B+树`的叶子节点之间通过双向链表链接，方便进行范围查询。

#### 5.3.3 B+树索引和Hash索引区别

Hash索引是通过哈希函数计算后得到`桶的编号`，然后将`桶`内的记录保存在链表或树结构中，因此Hash索引适合与`等值查询`。

同样的，Hash索引维护成本较低，只需简单的增加、删除链表中的记录；B+树索引则需要调整索引结构，并且可能需要`页分裂`或`页合并`等操作。

#### 5.3.4 唯一索引允许有NULL值吗

允许，并且允许有多个NULL值的存在。这是由于NULL被认为是`未知`的，因此NULL可能等于NULL，也可能不等于NULL，所以允许多个NULL值存在。

#### 5.3.5 最左匹配原则

因为索引底层是B+树索引，联合索引的情况下，在构造B+树时，会按照左边的key进行排序，左边key相同时，再往下一个key进行排序。所以通过索引查询时，需要遵循`最左匹配原则`，否则`查询不走索引`。

#### 5.3.6 一定要遵循最左匹配原则吗

在MySQL8.0.13版本中，引入了`索引跳跃扫描`，它支持在`不符合最左前缀原则下`，依然能够使用联合索引。

`索引跳跃扫描`原理：
给定联合索引`idx(a1,a2)`，其SQL为：`select a1,a2 from a where a2= 40`。
`索引跳跃扫描`会将a1的唯一值逐个取出，与a2构造为符合最左前缀原则，最后将结果合并返回，如：

```sql
select a1,a2 from a where a1=1 and a2=40 
union
select a1,a2 from a where a1=2 and a2=40
...
```

> 这种`索引跳跃扫描`的技术，在于a1的值的区分度，区分度高数据多则MySQL优化器不一定会选择`索引跳跃扫描`技术。
> 还有其他限制条件，诸如：不能多表join、不能使用Group By或Distinct语句等

### 5.4 SQL优化

#### 5.4.1 执行计划

MySQL执行计划通过`explain`进行分析。

```text
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+--------------------------+                                           
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                    |                                           
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+--------------------------+                                           
|  1 | SIMPLE      | t1    | NULL       | ref   | idx_t         | idx_t    | 4       | const|   80 |   100.00 | Using index              |       
```

- id: 操作的唯一标识。每个操作都有唯一的id。
- select_type: 操作的类型。SIMPLE、PRIMARY、SUBQUERY、UNION。
- table: 操作的表。
- partitions：操作涉及的分区。
- type: 查询所使用的索引类型。ALL、index、range、ref、eq_ref、const、system。
- possible_keys: 可能使用的索引。
- key: 所使用的索引。
- key_len: 索引的长度。越短效率越高
- ref: 哪些列或常量被用来与key列中命名的索引进行比较。
- rows: 扫描的行数。
- filtered: 过滤掉的行数占扫描行数的百分比。
- Extra： 其他信息。`Using index`、`Using filesort`、`Using temporary`

Extra其中的信息：

1. Using where：表示 MySQL 将在存储引擎检索行后，再进行条件过滤（使用 WHERE 子句）；查询的列未被索引覆盖，where筛选条件非索引的前导列或者where筛选条件非索引列。
2. Using index：：表示 MySQL 使用了覆盖索引（也称为索引覆盖）优化，只需要扫描索引，而无需回到数据表中检索行；
3. Using index condition：表示查询在索引上执行了部分条件过滤。这通常和索引下推有关。
4. Using where; Using index：查询的列被索引覆盖，并且where筛选条件是索引列之一，但不是索引的前导列，或者where筛选条件是索引列前导列的一个范围
5. Using join buffer：表示 MySQL 使用了连接缓存；
6. Using temporary：表示 MySQL 创建了临时表来存储查询结果。这通常是在排序或分组时发生的；
7. Using filesort：表示 MySQL 将使用文件排序而不是索引排序，这通常发生在无法使用索引来进行排序时；
...

#### 5.4.2 大规模的数据库系统如何优化

1. 硬件优化
2. 数据库表结构优化、旧数据归档
3. SQL优化
4. 索引优化
5. 缓存机制
6. 负载均衡、读写分离
7. 分区分片
8. 监控、备份

## 六、计算机基础

### 6.1 TCP和UDP是什么

TCP：Transmission Control Protocol 传输控制协议，需要建立连接后才能进行数据传输的协议。有**3次握手连接**和**4次挥手断开**。由于这样的连接、断开控制，因此TCP是一种**速度相对慢**但**可靠**的传输协议。

UDP：User Dadagram Protocol 用户数据报协议，不需要建立连接即可进行数据传输。由于不需要建立连接，因此UDP是一种**速度相对快**但有**数据丢包风险**的传输协议。

都是OSI网络七层模型中，位于**传输层**的网络传输协议。

为了更好理解TCP与UDP，看看日常使用中这两种传输协议的应用。

常见的TCP应用诸如：**电子邮箱点对点发送、文件传输**

常见的UDP应用诸如：**王者荣耀实时对抗、直播数据推送**

### 6.2 OSI网络七层模型

OSI：Open System Interconnection 开放系统互联。

OSI七层模型是计算机网络中通信协议的分类

- **物理层：规定传输介质的传输方式**。最基础的一层，信号、介质是这一层的概念。
- **数据链路层**：在**物理层**上，建立数据链路，进行数据的处理，将物理层的数据传入下一层：网络层。
- **网络层**：解决数据在网络中传输的问题，寻址、路由选择是这一层的概念。
- **传输层**：解决数据端对端的传输问题，传输控制、流量控制是这一层的概念。
- **会话层**：解决不同计算机之间会话管理的功能。
- **表示层**：解决数据格式的转换，如数据转为JPEG、数据加密解密等。
- **应用层**：多数程序员处于这层，解决应用程序交互等。

## 七、Nacos

### 7.1 什么是Nacos

Nacos是阿里巴巴开源的一款动态服务发现、配置管理、服务治理平台，与Spring Cloud深度集成。

- 动态服务发现：应用系统可以将服务注册到Nacos注册中心，通过Nacos实现动态配置和负载均衡，实现服务高可用。
- 配置管理：应用系统可以将配置信息存储到Nacos配置中心，通过Nacos实现动态管理配置，实现应用动态调整和部署。
- 服务治理：Nacos可以对注册的服务进行健康监测、故障转移、服务限流、熔断降级等治理，提高应用程序的可靠性。

### 7.2 Nacos是AP还是CP

> CAP理论：一个分布式系统最多只能满足CAP中的两项。
> C：一致性；A：可用性；P：分区容错性

**Nacos支持AP和CP两种模式。** 默认为AP模式，不保证强一致性，保证Nacos的高可用和可伸缩性。

具体要选择什么样的模式根据业务进行选择。

如金融、支付等需要强一致性的业务场景，则使用CP。

如网站、游戏等需要高可用，只需要保证最终一致性的业务场景，则使用AP。

### 7.3 Nacos如何实现配置变化客户端能够感知

在早期Nacos1.x版本中，客户端使用`长轮询`机制，主动去获取配置中心是否有变化。
在Nacos2.x版本中，客户端使用`gRPC长连接`机制，配置中心若有变化则会推送给客户端。

